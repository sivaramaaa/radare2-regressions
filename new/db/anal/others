NAME=a2f jmp after ret
FILE=malloc://512
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
EOF
RUN

NAME=a2f jmp after ret - _size (symsize)
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
afl~[2]
EOF
RUN

NAME=a2f jmp after ret - realsize (bbs_sum)
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
afl~[2]
EOF
RUN

NAME=a2f 8 bbs 4 ret and some jumps
FILE=malloc://512
EXPECT=<<EOF
0x00000000 0x00000004 00:0000 4 j 0x00000009 f 0x00000004
0x00000004 0x00000008 00:0000 4 j 0x0000000d f 0x00000008
0x00000008 0x00000009 00:0000 1
0x00000009 0x0000000d 00:0000 4 j 0x0000000e
0x0000000d 0x0000000e 00:0000 1
0x0000000e 0x00000012 00:0000 4 j 0x00000013 f 0x00000012
0x00000012 0x00000013 00:0000 1
0x00000013 0x00000019 00:0000 6
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=32
wx 85c0740585c07405c385c0eb01c385c07401c3b8efbeaddec3
a2f
afb
EOF
RUN

NAME=a2f 3bbs with entry in the middle of the function
FILE=malloc://512
EXPECT=<<EOF
0x00000000 0x0000000a 00:0000 10 j 0x0000000a
0x0000000a 0x0000000e 00:0000 4 j 0x00000000 f 0x0000000e
0x0000000e 0x00000014 00:0000 6
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=32
wx 31c031c983c10183c10285c975f231c931c040c3
s 0xa
a2f
afb
EOF
RUN

NAME=a2f 6 bbs with entry at the end of the function
FILE=malloc://512
EXPECT=<<EOF
0x00000000 0x0000000a 00:0000 10 j 0x00000012 f 0x0000000a
0x0000000a 0x00000012 00:0000 8 j 0x00000012
0x00000012 0x0000001c 00:0000 10 j 0x00000000 f 0x0000001c
0x0000001c 0x00000026 00:0000 10 j 0x00000028 f 0x00000026
0x00000026 0x00000028 00:0000 2 j 0x00000000
0x00000028 0x0000002b 00:0000 3
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=32
wx 31c083c00183e801750831c083e80183c00131c983c10183e90175e431d283ea0183c2017402ebd831c0c3
s 0x26
a2f
afb
EOF
RUN

NAME=a2f cjmp
FILE=malloc://0x5000
EXPECT=<<EOF
0x00000000 0x00000004 00:0000 4 j 0x00000005 f 0x00000004
0x00000004 0x00000005 00:0000 1 j 0x00000005
0x00000005 0x00000006 00:0000 1
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e io.cache=true
e asm.bits=32
wx 31c0740140c3
a2f
afb
EOF
RUN

NAME=aaa with axt
FILE=../bins/anal/keygen.exe
EXPECT=<<EOF
(nofunc) 0x4bfe53 [DATA] mov edx, 0x4bffb0
EOF
CMDS=<<EOF
aaa
axt 0x4bffb0
EOF
RUN

NAME=aaa with maxbbsz
FILE=../bins/anal/flare_notepad.ex
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
e anal.bb.maxsize = 2048
aaa
pdf~ret?
EOF
RUN

NAME=aaa with avra
FILE=../bins/elf/class_test
EXPECT=<<EOF
VMI Type Info at 0x08048f4c:
  Reference to RTTI's type class: 0x0804b140
  Reference to type's name: 0x08048f6c
  Type Name: Bat
  Flags: 0x0
  Count of base classes: 0x2
      Base class type descriptor address: 0x08048f74
      Base class flags: 0x2
      Base class type descriptor address: 0x08048fac
      Base class flags: 0x402

VMI Type Info at 0x08048f4c:
  Reference to RTTI's type class: 0x0804b140
  Reference to type's name: 0x08048f6c
  Type Name: Bat
  Flags: 0x0
  Count of base classes: 0x2
      Base class type descriptor address: 0x08048f74
      Base class flags: 0x2
      Base class type descriptor address: 0x08048fac
      Base class flags: 0x402

Type Info at 0x08048f74:
  Reference to RTTI's type class: 0x0804b048
  Reference to type's name: 0x08048f7c
  Type Name: Bird

SI Type Info at 0x08048f84:
  Reference to RTTI's type class: 0x0804b114
  Reference to type's name: 0x08048f90
  Type Name: Dog
  Reference to parent's type name: 0x08048fac

SI Type Info at 0x08048f98:
  Reference to RTTI's type class: 0x0804b114
  Reference to type's name: 0x08048fa4
  Type Name: Cat
  Reference to parent's type name: 0x08048fac

Type Info at 0x08048fac:
  Reference to RTTI's type class: 0x0804b048
  Reference to type's name: 0x08048fb4
  Type Name: Mammal

EOF
CMDS=<<EOF
aaa
avra
EOF
RUN

NAME=aac on mips be
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1269
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac with maps (less because of wrong map address)
FILE=../bins/elf/analysis/mipsbe-busybox
ARGS=-n -m 0x80000 -a mips -b32 -e cfg.bigendian=true
EXPECT=<<EOF
4
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac (using a PIC bin)
BROKEN=1
FILE=../bins/elf/libmagic.so
EXPECT=<<EOF
202
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac with maps (using a PIC bin)
BROKEN=1
FILE=../bins/elf/libmagic.so
ARGS=-n -m 0x80000 -a arm -b 16 -e cfg.bigendian=false
EXPECT=<<EOF
96
EOF
CMDS=<<EOF
aac
e search.in=io.maps
afl~?
EOF
RUN

NAME=aav without vinfun
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af @ 0x0040dea4
e anal.vinfun=false
aav
pd 1 @ 0x0040decc~?andi
EOF
RUN

NAME=aav with vinfun
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af @ 0x0040dea4
e anal.vinfun=true
aav
pd 1 @ 0x0040decc~?dword
EOF
RUN

NAME=aav thumb detection
FILE=../bins/firmware/armthumb.bin
ARGS=-aarm -b32
EXPECT=<<EOF
0x0000000d 4 aav.0x0000000d
EOF
CMDS=<<EOF
aav
f
EOF
RUN

NAME=arj x86 32 bits
FILE=malloc://0x100
EXPECT='{"oeax":0,"eax":0,"ebx":0,"ecx":0,"edx":0,"esi":0,"edi":0,"esp":0,"ebp":0,"eip":0,"eflags":0}
'
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e asm.bits=32
arj
EOF
RUN

NAME=arj x86 16 bits
FILE=malloc://0x100
EXPECT='{"ip":0,"ax":0,"bx":0,"cx":0,"dx":0,"sp":0,"bp":0,"si":0,"di":0,"flags":0}
'
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e asm.bits=16
arj
EOF
RUN

NAME=sym is not fcn
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
EOF
CMDS=<<EOF
aa > /dev/null
afl~sym.__mh_execute_header[0]
EOF
RUN

NAME=af x86-32
FILE=malloc://1024
EXPECT=<<EOF
6
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a00 4889e5 c3
af
afl~[2]
EOF
RUN

NAME=af x86-32 ujmp eobjmp=true
FILE=malloc://1024
EXPECT=<<EOF
11
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e anal.eobjmp=true
e asm.bits=32
wx 6a00 4889e5 ff25f8120000 ff25f8120000ffe0c3
af
afl~[2]
EOF
RUN

NAME=af x86-32 ujmp eobjmp=false
FILE=malloc://1024
EXPECT=<<EOF
11
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e anal.eobjmp=false
e asm.bits=32
wx 6a00 4889e5 ff25f8120000 ff25f8120000ffe0c3
af
afl~[2]
EOF
RUN

NAME=af bug
FILE=malloc://1024
EXPECT=<<EOF
push 0
dec eax
mov ebp, esp
dec eax
and esp, 0xfffffff0
dec eax
mov edi, dword [ebp + 8]
dec eax
lea esi, [ebp + 0x10]
mov edx, edi
add edx, 1
shl edx, 3
dec eax
add edx, esi
dec eax
mov ecx, edx
jmp 0x25
dec eax
add ecx, 8
dec eax
cmp dword [ecx], 0
jne 0x21
dec eax
add ecx, 8
call 0xf8c
mov edi, eax
call 0x3956
ret
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e anal.eobjmp=false
e asm.bits=32
wx 6a004889e54883e4f0488b7d08488d751089fa83c201c1e2034801f24889d1eb044883c1084883390075f64883c108e8580f000089c7e81b390000c3554889e5
s +0x40
wx 488d4768488d7e684889c6c9e9013a0000554889e54883c6684883c768c9e9ef390000554889e5534889f1488b5660488b4760488b583048395a307f1d7c2248
s -0x40
af
b 0x80
pIf
EOF
RUN

NAME=disasm bug
FILE=malloc://1024
EXPECT=<<EOF
push 0
dec eax
mov ebp, esp
dec eax
and esp, 0xfffffff0
dec eax
mov edi, dword [ebp + 8]
dec eax
lea esi, [ebp + 0x10]
mov edx, edi
add edx, 1
shl edx, 3
dec eax
add edx, esi
dec eax
mov ecx, edx
jmp 0x25
dec eax
add ecx, 8
dec eax
cmp dword [ecx], 0
jne 0x21
dec eax
add ecx, 8
call 0xf8c
mov edi, eax
call 0x3956
ret
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a004889e54883e4f0488b7d08488d751089fa83c201c1e2034801f24889d1eb044883c1084883390075f64883c108e8580f000089c7e81b390000c3554889e5
s+0x40
wx 488d4768488d7e684889c6c9e9013a0000554889e54883c6684883c768c9e9ef390000554889e5534889f1488b5660488b4760488b583048395a307f1d7c2248
s-0x40
b 0x100
af
pIf @0
EOF
RUN

NAME=call-convention
FILE=../bins/elf/analysis/x86-simple
EXPECT=<<EOF
call-convention: stdcall
EOF
CMDS=<<EOF
aa
s entry0
afc stdcall
afi~call-convention
EOF
RUN

NAME=function address
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f50
0x00001f00
EOF
CMDS=<<EOF
e anal.hasnext=0
aa
afo sym._foo
afo sym._bar
EOF
RUN

NAME=afr
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00    4 73           sym._bar
0x00001f50    1 47           sym._foo
0x00001f80    1 41           sym._main
EOF
CMDS=<<EOF
e anal.hasnext=0
afr
afl
EOF
RUN

NAME=aF
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f80    1 41           sym._main
EOF
CMDS=<<EOF
e anal.hasnext=0
aF
afl
EOF
RUN

NAME=function prelude offsets
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00
0x00001f50
0x00001f80
EOF
CMDS=<<EOF
s 0x1000
aap
afl~[0]
EOF
RUN

NAME=function preludes symbol names
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00    4 73           sym._bar
0x00001f50    1 47           sym._foo
0x00001f80    1 41           sym._main
EOF
CMDS=<<EOF
s 0x1000
aap
afl
EOF
RUN

NAME=af afF
FILE=malloc://1024
EXPECT=<<EOF
/ (fcn) fcn.test
\           0x00000000 (6 byte folded function)
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a004889e5c3
af test
afF
pd 1 @ fcn.test
EOF
RUN

NAME=af afF graph
FILE=malloc://1024
EXPECT=<<EOF
[0x00000000]> VV @ fcn.test (nodes 1 edges 0 zoom 100%) BB-NORM mouse:canvas-y mov-speed:5
.---------------------------.
|  0x0                      |
| / (fcn) fcn.test          |
| (6 byte folded function)  |
`---------------------------'
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a004889e5c3
af test
afF
agf
EOF
RUN

NAME=af-*
FILE=../bins/elf/analysis/main
EXPECT=<<EOF
EOF
CMDS=<<EOF
aa
af-*
afl
EOF
RUN

NAME=ahc
FILE=malloc://16
EXPECT=<<EOF
5
0x00000025
0x00000025
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx ebfe
ahs 5
ahc 0x25
ahf 0x25
ao 1~jump,fail,size[1]
EOF
RUN

NAME=ahi S
FILE=malloc://16
EXPECT=<<EOF
mov eax, exit()
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
e asm.os=linux
wx b801000000
ahi S
pi 1
EOF
RUN

NAME=iS. and iSj. implementation
FILE=../bins/anal/lab1B
EXPECT='Current section
Nm Paddr       Size Vaddr      Memsz Perms Checksum          Name
00 0x00000188    36 0x08048188    36 -r-- .note.gnu.build_id
Current section
Nm Paddr       Size Vaddr      Memsz Perms Checksum          Name
{"name":".plt","size":240,"vsize":240,"perm":"-r-x","paddr":1888,"vaddr":134514528}'
CMDS=<<EOF
s 0x188
iS.
s 0x08058000
iS.
s 0x760
iSj.
EOF
RUN

NAME=iE and iE. implementation
FILE=../bins/anal/lab1B
EXPECT='Num Paddr      Vaddr      Bind     Type Size Name
022 0x000009b7 0x080489b7 GLOBAL   FUNC  189 decrypt
{"name":"prog_timeout","demname":"","flagname":"sym.prog_timeout","ordinal":35,"bind":"GLOBAL","size":17,"type":"FUNC","vaddr":134515110,"paddr":2470}'
CMDS=<<EOF
s 0x080489b9
iE.
s 0x080489a6
s+5
isj.
EOF
RUN

NAME=address information
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
exec
read
flag
flag
EOF
CMDS=<<EOF
s entry0
ai
s sym.__mh_execute_header
ai
EOF
RUN

NAME=af x86-32
FILE=malloc://16
EXPECT=<<EOF
15
address: 0x0
opcode: nop
mnemonic: nop
prefix: 0
id: 494
bytes: 90
refptr: 0
size: 1
sign: false
type: nop
cycles: 1
esil: ,
stack: null
family: cpu
stackop: null
90
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx 9090
ao 1~?
ao 1
p8 1
EOF
RUN

NAME=af x86-64
FILE=malloc://16
EXPECT=<<EOF
10
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
wx 662e0f1f840000000000
ao 1~size[1]
EOF
RUN

NAME=anal/fcn_name
FILE=../bins/elf/analysis/main-g
EXPECT=<<EOF
/ (fcn) sym.call_gmon_start 23
EOF
CMDS=<<EOF
s 0x0040042c
af
pd 1~sym.call_gmon_start:0
EOF
RUN

NAME=anal/fcn_subname
FILE=../bins/elf/analysis/main-g
EXPECT=<<EOF
name: sym.call_gmon_start
/ (fcn) sym.call_gmon_start 23
EOF
CMDS=<<EOF
s 0x0040042c
af
afi~name
pd 1~sym.call_gmon_start:0
EOF
RUN

NAME=anal/name
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
name: main
EOF
CMDS=<<EOF
af
afi~name
EOF
RUN

NAME=anal hasnext on main
FILE=../bins/elf/true32
EXPECT=<<EOF
size: 261
EOF
CMDS=<<EOF
e anal.hasnext=true
af@main
afi@main~size
EOF
RUN

NAME=anal without hasnext on main
FILE=../bins/elf/true32
EXPECT=<<EOF
size: 261
EOF
CMDS=<<EOF
e anal.hasnext=false
af@main
afi@main~size
EOF
RUN

NAME=ahe
FILE=malloc://512
EXPECT=<<EOF
15
esil: test
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch = x86
e anal.arch = x86
ao~?
ahe test
ao~esil
EOF
RUN

NAME=ahe2
FILE=malloc://512
EXPECT=<<EOF
esil: test
EOF
CMDS=<<EOF
ahe test
ao~^esil
EOF
RUN

NAME=ahe 33,rax,=
FILE=malloc://512
EXPECT=<<EOF
0x00000021
EOF
CMDS=<<EOF
wx 000000
ahe 33,rax,=
aes
dr?rax
EOF
RUN

NAME=delete memory format with Cf-
FILE=../bins/dmg/src/Hello
EXPECT=<<EOF
            0x00000000      57             push rdi
            0x00000000 format x {
0x00000000 = 0x6c726f57
} 1
temp_proj
            0x00000000      57             push rdi
temp_proj
            0x00000000      57             push rdi
EOF
CMDS=<<EOF
pd 1
Cf 1 x
pd 1
Ps temp_proj
Cf-
pd 1
Ps temp_proj
Po temp_proj
pd 1
EOF
RUN

NAME=ao cjmp
FILE=-
EXPECT=<<EOF
size: 2
jump: 0x0000001d
fail: 0x00000002
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx 761b
ao~jump,fail,size
EOF
RUN

NAME=aoj 31c0
FILE=-
EXPECT='[
  {
    "opcode": "xor eax, eax",
    "disasm": "xor eax, eax",
    "mnemonic": "xor",
    "esil": "eax,eax,^=,$z,zf,=,$p,pf,=,$s,sf,=,$0,cf,=,$0,of,=",
    "sign": false,
    "prefix": 0,
    "id": 334,
    "opex": {
      "operands": [
        {
          "size": 4,
          "rw": 3,
          "type": "reg",
          "value": "eax"
        },
        {
          "size": 4,
          "rw": 1,
          "type": "reg",
          "value": "eax"
        }
      ],
      "modrm": true
    },
    "addr": 0,
    "bytes": "31c0",
    "size": 2,
    "type": "xor",
    "scale": 0,
    "refptr": 0,
    "cycles": 1,
    "failcycles": 0,
    "delay": 0,
    "stackptr": 0,
    "family": "cpu"
  }
]
'
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx 31c0
aoj~{}
EOF
RUN

NAME=reflines offset
FILE=malloc://1023
CMDS=<<EXPECT
e asm.calls=false
e asm.bits=32
e asm.leahints=false
e asm.cpu=x86
e asm.arch=x86
e anal.cpu=x86
e scr.utf8=true
e asm.comments=false
e asm.bytes=false
e scr.color=false
wx 31c039d6724aeb72908db426000000008d7e0131d289e8f7f131d28944241c89f8f7f13944241c76678b93080200008b028b50143b5018736dc6020983c20189501489f031d201cef7f129d639f5762a8b8b8c05000085c975b683c6018b93080200008b028b50143b50187327c6022083c20139f589501477d68b44242c65330514000000753783c43c5b5e5f5dc39089feebc9c744240420000000890424e87cc9ffffeba6c744240409000000890424e86ac9ffff8b8b8c050000eb84e87d1001008db6000000008dbc270000000055575653e8f7f0ffff81c32b9d010083ec3c658b0d14000000894c242c31c98b6a0c8b720889e929f1c1e90285c9894c241c0f848100000039f50f84930000008b7a1801fdf7d721fd8b7a1089e9896a0c2b4a0489fd2b6a0439e97f718b7a0c31ed
aa > /dev/null
pd 38
EXPECT=<<RUN
┌ (fcn) fcn.00000000 1645
│           ; var int var_4h @ esp+0x4
│           ; var int var_1ch @ esp+0x1c
│           ; var int var_2ch @ esp+0x2c
│           0x00000000      xor eax, eax
│           0x00000002      cmp esi, edx
│       ┌─< 0x00000004      jb 0x50
│      ┌──< 0x00000006      jmp 0x7a
       ││   0x00000008      nop
       ││   0x00000009      lea esi, [esi]
│     ┌───> 0x00000010      lea edi, [esi + 1]
│     ╎││   0x00000013      xor edx, edx
│     ╎││   0x00000015      mov eax, ebp
│     ╎││   0x00000017      div ecx
│     ╎││   0x00000019      xor edx, edx
│     ╎││   0x0000001b      mov dword [var_1ch], eax
│     ╎││   0x0000001f      mov eax, edi
│     ╎││   0x00000021      div ecx
│     ╎││   0x00000023      cmp dword [var_1ch], eax
│    ┌────< 0x00000027      jbe 0x90
│    │╎││   0x00000029      mov edx, dword [ebx + 0x208]
│    │╎││   0x0000002f      mov eax, dword [edx]
│    │╎││   0x00000031      mov edx, dword [eax + 0x14]
│    │╎││   0x00000034      cmp edx, dword [eax + 0x18]
│   ┌─────< 0x00000037      jae 0xa6
│   ││╎││   0x00000039      mov byte [edx], 9
│   ││╎││   0x0000003c      add edx, 1
│   ││╎││   0x0000003f      mov dword [eax + 0x14], edx
│   ││╎││   0x00000042      mov eax, esi
│   ││╎││   0x00000044      xor edx, edx
│   ││╎││   0x00000046      add esi, ecx
│   ││╎││   0x00000048      div ecx
│   ││╎││   0x0000004a      sub esi, edx
│   ││╎││   0x0000004c      cmp ebp, esi
│  ┌──────< 0x0000004e      jbe 0x7a
│  │││╎│└─> 0x00000050      mov ecx, dword [ebx + 0x58c]
│  │││╎│    0x00000056      test ecx, ecx
│  │││└───< 0x00000058      jne 0x10
│  │││ │    0x0000005a      add esi, 1
│  │││ │    0x0000005d      mov edx, dword [ebx + 0x208]
│  │││ │    0x00000063      mov eax, dword [edx]
│  │││ │    0x00000065      mov edx, dword [eax + 0x14]
RUN

NAME=reflines offset (ascii)
FILE=malloc://1023
CMDS=<<EXPECT
e asm.calls=false
e asm.bits=32
e asm.leahints=false
e asm.cpu=x86
e anal.cpu=x86
e asm.arch=x86
e asm.comments=false
e asm.bytes=false
e scr.utf8=false
e scr.color=false
wx 31c039d6724aeb72908db426000000008d7e0131d289e8f7f131d28944241c89f8f7f13944241c76678b93080200008b028b50143b5018736dc6020983c20189501489f031d201cef7f129d639f5762a8b8b8c05000085c975b683c6018b93080200008b028b50143b50187327c6022083c20139f589501477d68b44242c65330514000000753783c43c5b5e5f5dc39089feebc9c744240420000000890424e87cc9ffffeba6c744240409000000890424e86ac9ffff8b8b8c050000eb84e87d1001008db6000000008dbc270000000055575653e8f7f0ffff81c32b9d010083ec3c658b0d14000000894c242c31c98b6a0c8b720889e929f1c1e90285c9894c241c0f848100000039f50f84930000008b7a1801fdf7d721fd8b7a1089e9896a0c2b4a0489fd2b6a0439e97f718b7a0c31ed
aa >/dev/null
pd 38
EXPECT=<<RUN
/ (fcn) fcn.00000000 1645
|           ; var int var_4h @ esp+0x4
|           ; var int var_1ch @ esp+0x1c
|           ; var int var_2ch @ esp+0x2c
|           0x00000000      xor eax, eax
|           0x00000002      cmp esi, edx
|       ,=< 0x00000004      jb 0x50
|      ,==< 0x00000006      jmp 0x7a
       ||   0x00000008      nop
       ||   0x00000009      lea esi, [esi]
|     .---> 0x00000010      lea edi, [esi + 1]
|     :||   0x00000013      xor edx, edx
|     :||   0x00000015      mov eax, ebp
|     :||   0x00000017      div ecx
|     :||   0x00000019      xor edx, edx
|     :||   0x0000001b      mov dword [var_1ch], eax
|     :||   0x0000001f      mov eax, edi
|     :||   0x00000021      div ecx
|     :||   0x00000023      cmp dword [var_1ch], eax
|    ,====< 0x00000027      jbe 0x90
|    |:||   0x00000029      mov edx, dword [ebx + 0x208]
|    |:||   0x0000002f      mov eax, dword [edx]
|    |:||   0x00000031      mov edx, dword [eax + 0x14]
|    |:||   0x00000034      cmp edx, dword [eax + 0x18]
|   ,=====< 0x00000037      jae 0xa6
|   ||:||   0x00000039      mov byte [edx], 9
|   ||:||   0x0000003c      add edx, 1
|   ||:||   0x0000003f      mov dword [eax + 0x14], edx
|   ||:||   0x00000042      mov eax, esi
|   ||:||   0x00000044      xor edx, edx
|   ||:||   0x00000046      add esi, ecx
|   ||:||   0x00000048      div ecx
|   ||:||   0x0000004a      sub esi, edx
|   ||:||   0x0000004c      cmp ebp, esi
|  ,======< 0x0000004e      jbe 0x7a
|  |||:|`-> 0x00000050      mov ecx, dword [ebx + 0x58c]
|  |||:|    0x00000056      test ecx, ecx
|  |||`===< 0x00000058      jne 0x10
|  ||| |    0x0000005a      add esi, 1
|  ||| |    0x0000005d      mov edx, dword [ebx + 0x208]
|  ||| |    0x00000063      mov eax, dword [edx]
|  ||| |    0x00000065      mov edx, dword [eax + 0x14]
RUN

NAME=reflines offset 2 (ascii)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|       ,=< 0x000113bd      je 0x1144e
|       |   0x000113c3      mov esi, 0x2f                              ; '/' ; int c
|       |   0x000113c8      call sym.imp.strrchr                       ; char *strrchr(const char *s, int c)
|       |   0x000113cd      test rax, rax
|      ,==< 0x000113d0      je 0x11424
|      ||   0x000113d2      lea rdx, [rax + 1]
|      ||   0x000113d6      mov rcx, rdx
|      ||   0x000113d9      sub rcx, rbx
|      ||   0x000113dc      cmp rcx, 6
|     ,===< 0x000113e0      jle 0x11424
|     |||   0x000113e2      lea rsi, [rax - 6]
|     |||   0x000113e6      mov ecx, 7
|     |||   0x000113eb      lea rdi, [rip + 0x7ebb]                    ; str..libs ; 0x192ad ; "/.libs/"
|     |||   0x000113f2      repe cmpsb byte [rsi], byte ptr [rdi]
|    ,====< 0x000113f4      jne 0x11424
|    ||||   0x000113f6      mov ecx, 3
|    ||||   0x000113fb      mov rsi, rdx
|    ||||   0x000113fe      mov rbx, rdx
|    ||||   0x00011401      lea rdi, [rip + 0x7ead]                    ; "lt-" ; 0x192b5
|    ||||   0x00011408      repe cmpsb byte [rsi], byte ptr [rdi]
|    ||||   0x0001140a      seta sil
|    ||||   0x0001140e      setb cl
|    ||||   0x00011411      cmp sil, cl
|   ,=====< 0x00011414      jne 0x11424
|   |||||   0x00011416      lea rbx, [rax + 4]
|   |||||   0x0001141a      mov rax, qword [rip + 0xdeaf]              ; reloc.program_invocation_short_name ; [0x1f2d0:8]=0
|   |||||   0x00011421      mov qword [rax], rbx
|   |||||   ; CODE XREFS from sub.strrchr_11390 (0x113d0, 0x113e0, 0x113f4, 0x11414)
|   ````--> 0x00011424      mov rax, qword [rip + 0xde3d]              ; [0x1f268:8]=0x21680
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
s $S
aaa >/dev/null
s 0x000113bd
pd 28
EOF
RUN

NAME=reflines offset 3 (ascii)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|       ,=< 0x00003ca9      je 0x45ec
|       |   0x00003caf      cmp eax, 3
|      ,==< 0x00003cb2      je 0x3ce3
|      ||   0x00003cb4      sub eax, 1
|     ,===< 0x00003cb7      je 0x3cbe
|     |||   ; CODE XREF from main (0x58bc)
|     |||   0x00003cb9      call sym.imp.abort                         ; void abort(void)
|     |||   ; CODE XREF from main (0x3cb7)
|     `---> 0x00003cbe      mov edi, 1                                 ; int fd
|      ||   0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|      ||   0x00003cc8      test eax, eax
|     ,===< 0x00003cca      je 0x4c2e
|     |||   0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|     |||   0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
|    ,====< 0x00003ce1      jmp 0x3cf9
|    ||||   ; CODE XREF from main (0x3cb2)
|    ||`--> 0x00003ce3      mov esi, 5
|    || |   0x00003ce8      xor edi, edi
|    || |   0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|    || |   0x00003cf4      call sub.__stack_chk_fail_12740
|    || |   ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
|    `----> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
s $S
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines offset 3 (ascii + wide)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|      ,==< 0x00003ca9      je 0x45ec
|      |    0x00003caf      cmp eax, 3
|    ,====< 0x00003cb2      je 0x3ce3
|    | |    0x00003cb4      sub eax, 1
|  ,======< 0x00003cb7      je 0x3cbe
|  | | |    ; CODE XREF from main (0x58bc)
|  | | |    0x00003cb9      call sym.imp.abort                         ; void abort(void)
|  | | |    ; CODE XREF from main (0x3cb7)
|  `------> 0x00003cbe      mov edi, 1                                 ; int fd
|    | |    0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|    | |    0x00003cc8      test eax, eax
|  ,======< 0x00003cca      je 0x4c2e
|  | | |    0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|  | | |    0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
| ========< 0x00003ce1      jmp 0x3cf9
|  | | |    ; CODE XREF from main (0x3cb2)
|  | `----> 0x00003ce3      mov esi, 5
|  |   |    0x00003ce8      xor edi, edi
|  |   |    0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|  |   |    0x00003cf4      call sub.__stack_chk_fail_12740
|  |   |    ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
| --------> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
s $S
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines offset 4 (ascii + wide)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|      ,==< 0x00003ca9      je 0x45ec
|      |    0x00003caf      cmp eax, 3
|    ,====< 0x00003cb2      je 0x3ce3
|    | |    0x00003cb4      sub eax, 1
|  ,======< 0x00003cb7      je 0x3cbe
|  | | |    ; CODE XREF from main (0x58bc)
|  | | |    0x00003cb9      call sym.imp.abort                         ; void abort(void)
|  | | |    ; CODE XREF from main (0x3cb7)
|  `------> 0x00003cbe      mov edi, 1                                 ; int fd
|    | |    0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|    | |    0x00003cc8      test eax, eax
|  ,======< 0x00003cca      je 0x4c2e
|  | | |    0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|  | | |    0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
| ========< 0x00003ce1      jmp 0x3cf9
|  | | |    ; CODE XREF from main (0x3cb2)
|  | `----> 0x00003ce3      mov esi, 5
|  |   |    0x00003ce8      xor edi, edi
|  |   |    0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|  |   |    0x00003cf4      call sub.__stack_chk_fail_12740
|  |   |    ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
| --------> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines in noreturn
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
/ (fcn) sub.__stack_chk_fail_12740 76
|   sub.__stack_chk_fail_12740 (int arg2);
|           ; var int var_8h @ rbp-0x8
|           ; arg int arg2 @ rsi
|           0x00012740      push rbp
|           0x00012741      mov rbp, rsp
|           0x00012744      sub rsp, 0x1030
|           0x0001274b      or qword [rsp], 0
|           0x00012750      add rsp, 0x1020
|           0x00012757      mov rax, qword fs:[0x28]
|           0x00012760      mov qword [var_8h], rax
|           0x00012764      xor eax, eax
|           0x00012766      lea rax, [rip + 0xf033]
|           0x0001276d      test rdi, rdi
|           0x00012770      cmovne rax, rdi
|           0x00012774      mov dword [rax], esi
|           0x00012776      mov rax, qword [var_8h]
|           0x0001277a      xor rax, qword fs:[0x28]
|      ,==< 0x00012783      jne 0x12787
|      |    0x00012785      leave
|      |    0x00012786      ret
\      `--> 0x00012787      call sym.imp.__stack_chk_fail
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
e asm.comments=0
aaa >/dev/null
s 0x00012740
pdf
EOF
RUN

NAME=⁝ and XREF cmt
FILE=../bins/elf/strenc-ctrlchars
EXPECT=<<EOF

┌ (fcn) sym.imp.puts 6
│   int sym.imp.puts (const char *s);
│       ╎   ; CALL XREF from sym.main (0x400406)
└       ╎   0x004003f0      jmp qword reloc.puts                       ; [0x601018:8]=0x4003f6
        ╎   0x004003f6      push 0
        └─< 0x004003fb      jmp 0x4003e0
EOF
CMDS=<<EOF
e scr.utf8=true
e asm.bytes=false
s main
af
s sym.imp.puts
?e
pd 3
EOF
RUN

NAME=stackptr
FILE=../bins/mach0/mac-ls
EXPECT=<<EOF
104
8
48-
40-
32-
24-
16-
8-
EOF
CMDS=<<EOF
s 0x1000039b6
af
e asm.lines.bb=false
e asm.lines.fcn=false
e asm.stackptr=true
pdr~0x100003b27[1]
pdf~0x100003b27[1]
pdr~0x100003b3d[1]
pdr~0x100003b3e[1]
pdr~0x100003b40[1]
pdr~0x100003b42[1]
pdr~0x100003b44[1]
pdr~0x100003b46[1]
EOF
RUN

NAME=auto string memory reference (iopa)
FILE=malloc://8096
EXPECT=<<EOF
  ; [0x1048:8]=0x500 "Hello"
  0x00000000      mov rsi, qword [rip + 0x1041]
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.arch = x86
e asm.bits=64
e scr.color = false
e io.va=0
e asm.lines.bb=0
e asm.bytes=0
e asm.cmt.right=10
wx 488b3541100000
wv8 0x500 @ 0x1048
w Hello @ 0x500
pd 1
EOF
RUN

NAME=auto string memory reference (io.va)
FILE=malloc://8096
EXPECT=<<EOF
  ; [0x1048:8]=0x500 "Hello"
  0x00000000      mov rsi, qword [rip + 0x1041]
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.arch = x86
e asm.bits=64
e scr.color = false
e io.va=1
e asm.lines.bb=0
e asm.bytes=0
e asm.cmt.right=10
wx 488b3541100000
wv8 0x500 @ 0x1048
w Hello @ 0x500
pd 1
EOF
RUN

NAME=no string on jmp
FILE=malloc://8096
EXPECT=<<EOF
        ,=< 0x00000000      e9fb000000     jmp 0x100
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
e emu.str=true
wa jmp 0x100
w hello @ 0x100
pd 1
EOF
RUN

NAME=no string on cbz
FILE=malloc://8096
EXPECT=<<EOF
            0x00000000      15008052       movz w21, 0
        ,=< 0x00000004      b5000034       cbz w21, 0x18               ; likely
EOF
CMDS=<<EOF
e asm.arch=arm
e asm.bits=64
e cfg.bigendian=false
e emu.str=true
wv 0x52800015
wv 0x340000b5 @ 4
w hello @ 0x18
pd 2
EOF
RUN

NAME=No function
FILE=malloc://0x50
EXPECT=<<EOF
EOF
CMDS=<<EOF
aftm
EOF
RUN

NAME=Basic type Matching
FILE=../bins/elf/analysis/x86-helloworld-gcc
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
s sym.main
aa
aei
aeim
td int puts(char *s);
aft
s 0x08048409
pd 1~char *s?
EOF
RUN

NAME=call not function
FILE=../bins/pe/crackme0x00.exe
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
aa
s sym._main
aei
aeim
td int strcmp(char *s1, char *s2);
tk func.strcmp.cc=stdcall
aft
s 0x00401368
pd 1~char *s1?
s 0x00401370
pd 1~char *s2?
EOF
RUN

NAME=1: Wrong calling convention
FILE=../bins/pe/crackme0x00.exe
EXPECT=<<EOF
EOF
CMDS=<<EOF
s entry0
af
tk CRTStartup=func
tk func.CRTStartup.args=1
tk func.CRTStartup.arg0= int,who_cares
tk func.CRTStartup.cc=THE_CC_THAT_NEVER_EXISTED
tk func.CRTStartup.ret=eax
aei
aeim
aftm
EOF
RUN

NAME=2: Wrong calling convention
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
int category
int fd
unsigned long request
EOF
CMDS=<<EOF
s entry0
aaa
afta
Ct. @ 0x100001413
Ct. @ 0x10000145b
Ct. @ 0x100001460
EOF
RUN

NAME=Function definition
FILE=../bins/elf/arm1.bin
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
afr @ main
s 0x000082cc
pd 1~?*xmalloc
EOF
RUN

NAME=Function definition (autorename)
FILE=../bins/pe/hello-mingw32
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
s 0x00401255
pd 1~?ExitProcess(UINT
EOF
RUN

NAME=Function definition
FILE=../bins/elf/ioli/crackme0x00
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
s 0x08048469
pd 1~?strcmp(const
EOF
RUN

NAME=afvt
FILE=../bins/mach0/arg
EXPECT=<<EOF
var int var_14h @ rbp-0x14
var int var_10h @ rbp-0x10
var int var_8h @ rbp-0x8
arg int arg1 @ rdi
arg int arg2 @ rsi
EOF
CMDS=<<EOF
s sym._call
af
afv
EOF
RUN

NAME=afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var char var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afv~var_30h
EOF
RUN

NAME=afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var int mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afv~mylocal
EOF
RUN

NAME=afvn + afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var int var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afvn var_30h mylocal
afv~var_30h
EOF
RUN

NAME=afvt + afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var char mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afvt mylocal char
afv~mylocal
EOF
RUN

NAME=afvn + afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var char mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afvn mylocal var_30h
afv~mylocal
EOF
RUN

NAME=afvt + afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var int var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afvt var_30h int
afv~var_30h
EOF
RUN

NAME=afva for esp based vars
FILE=malloc://1024
EXPECT=<<EOF
/ (fcn) fcn.00000000 89
|           ; var int var_4h @ esp+0x4
|           ; var int var_8h @ esp+0x8
|           ; var int var_ch @ esp+0xc
|           ; arg int arg_14h @ esp+0x14
|           ; arg int arg_18h @ esp+0x18
|           ; arg int arg_1ch @ esp+0x1c
|           ; arg int arg_20h @ esp+0x20
|           ; arg int arg_28h @ esp+0x28
|           ; arg int arg_2ch @ esp+0x2c
|           0x00000000      83ec10         sub esp, 0x10
|           0x00000003      8b442418       mov eax, dword [arg_18h]
|           0x00000007      99             cdq
|           0x00000008      f77c241c       idiv dword [arg_1ch]
|           0x0000000c      8b442414       mov eax, dword [arg_14h]
|           0x00000010      01d0           add eax, edx
|           0x00000012      8944240c       mov dword [var_ch], eax
|           0x00000016      8b442420       mov eax, dword [arg_20h]
|           0x0000001a      99             cdq
|           0x0000001b      f77c2428       idiv dword [arg_28h]
|           0x0000001f      8b44240c       mov eax, dword [var_ch]
|           0x00000023      01d0           add eax, edx
|           0x00000025      89442408       mov dword [var_8h], eax
|           0x00000029      8b542414       mov edx, dword [arg_14h]
|           0x0000002d      8b44240c       mov eax, dword [var_ch]
|           0x00000031      8d0c02         lea ecx, [edx + eax]
|           0x00000034      8b44242c       mov eax, dword [arg_2ch]
|           0x00000038      99             cdq
|           0x00000039      f7f9           idiv ecx
|           0x0000003b      8b442408       mov eax, dword [var_8h]
|           0x0000003f      01d0           add eax, edx
|           0x00000041      89442404       mov dword [var_4h], eax
|           0x00000045      8b54240c       mov edx, dword [var_ch]
|           0x00000049      8b442408       mov eax, dword [var_8h]
|           0x0000004d      01c2           add edx, eax
|           0x0000004f      8b442404       mov eax, dword [var_4h]
|           0x00000053      01d0           add eax, edx
|           0x00000055      83c410         add esp, 0x10
\           0x00000058      c3             ret
EOF
CMDS=<<EOF
e asm.bits=32
e asm.arch = x86
e anal.arch = x86
e asm.calls=false
wx 83ec108b44241899f77c241c8b44241401d08944240c8b44242099f77c24288b44240c01d0894424088b5424148b44240c8d0c028b44242c99f7f98b44240801d0894424048b54240c8b44240801c28b44240401d083c410c38d4c240483e4f0ff71fc5589e55183ec046a076a066a056a046a036a026a01e883ffffff83c41c83ec08506844850408e847feffff83c410b8000000008b4dfcc98d61fcc36690669066909055575653e887feffff81c3371b000083ec0c8b6c24208db30cffffffe8d3fdffff8d8308ffffff29c6c1fe0285f6742531ff8db60000000083ec04ff74242cff74242c55ff94bb08ffffff83c70183c41039f775e383c40c5b5e5f
e asm.bits=32
e asm.comments=false
aa
afva
pdf
EOF
RUN

NAME=afva for fastcall with no esp vars
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
fastcall
/ (fcn) sym.fastcaslled 59
|   sym.fastcaslled (int arg2, int arg1, int arg_8h, int arg_ch);
|           ; var int var_20h @ ebp-0x20
|           ; var int var_1ch @ ebp-0x1c
|           ; var int var_10h @ ebp-0x10
|           ; var int var_ch @ ebp-0xc
|           ; arg int arg_8h @ ebp+0x8
|           ; arg int arg_ch @ ebp+0xc
|           ; arg int arg2 @ edx
|           ; arg int arg1 @ ecx
|           ; CALL XREF from sym.main (0x80484c7)
|           0x0804841b      55             push ebp
|           0x0804841c      89e5           mov ebp, esp
|           0x0804841e      83ec28         sub esp, 0x28               ; '('
|           0x08048421      894de4         mov dword [var_1ch], ecx    ; arg1
|           0x08048424      8955e0         mov dword [var_20h], edx    ; arg2
|           0x08048427      8b55e4         mov edx, dword [var_1ch]
|           0x0804842a      8b45e0         mov eax, dword [var_20h]
|           0x0804842d      01d0           add eax, edx
|           0x0804842f      8945f4         mov dword [var_ch], eax
|           0x08048432      8b45e0         mov eax, dword [var_20h]
|           0x08048435      2b450c         sub eax, dword [arg_ch]
|           0x08048438      8945f0         mov dword [var_10h], eax
|           0x0804843b      ff7508         push dword [arg_8h]
|           0x0804843e      ff75f0         push dword [var_10h]
|           0x08048441      ff75f4         push dword [var_ch]
|           0x08048444      6874850408     push str.i__i__i            ; 0x8048574 ; "%i %i %i\n"
|           0x08048449      e8a2feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804844e      83c410         add esp, 0x10
|           0x08048451      90             nop
|           0x08048452      c9             leave
\           0x08048453      c20800         ret 8
EOF
CMDS=<<EOF
aa
s sym.fastcaslled
afc fastcall
afc
afva
pdf
EOF
RUN

NAME=afva for cdecl/stdcall with no esp vars
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
cdecl
/ (fcn) sym.nonfastcaslled 51
|           ; var int var_10h @ ebp-0x10
|           ; var int var_ch @ ebp-0xc
|           ; arg int arg_8h @ ebp+0x8
|           ; arg int arg_ch @ ebp+0xc
|           ; arg int arg_10h @ ebp+0x10
|           ; arg int arg_14h @ ebp+0x14
|           ; CALL XREF from sym.main (0x80484db)
|           0x08048456      55             push ebp
|           0x08048457      89e5           mov ebp, esp
|           0x08048459      83ec18         sub esp, 0x18
|           0x0804845c      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
|           0x0804845f      8b450c         mov eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|           0x08048462      01d0           add eax, edx
|           0x08048464      8945f4         mov dword [var_ch], eax
|           0x08048467      8b450c         mov eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|           0x0804846a      2b4514         sub eax, dword [arg_14h]
|           0x0804846d      8945f0         mov dword [var_10h], eax
|           0x08048470      ff7510         push dword [arg_10h]
|           0x08048473      ff75f0         push dword [var_10h]
|           0x08048476      ff75f4         push dword [var_ch]
|           0x08048479      6874850408     push str.i__i__i            ; 0x8048574 ; "%i %i %i\n"
|           0x0804847e      e86dfeffff     call sym.imp.printf
|           0x08048483      83c410         add esp, 0x10
|           0x08048486      90             nop
|           0x08048487      c9             leave
\           0x08048488      c3             ret
EOF
CMDS=<<EOF
e asm.calls=false
aa
s sym.nonfastcaslled
afc
afva
pdf
EOF
RUN

NAME=anal vars crash
FILE=-
EXPECT=<<EOF
EOF
CMDS=<<EOF
af
afvr-*
afvr-*
EOF
RUN

NAME=anal vars crash 2
FILE=-
EXPECT=<<EOF
/ (fcn) fcn.00000000 62
|           ; var int my_local @ rbp-0x18
|           ; arg int arg1 @ rdi
|           0x00000000      0000           add byte [rax], al
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch = x86
e anal.arch = x86
e asm.calls=false
wx 554889e5534881ec3810000048830c24004881c42010000064488b042528000000488945e831c04885ff4889fb909090909090c3 @ 10
aa
afvn new_1 old_1
afvn my_local var_18h
pd 1
EOF
RUN

NAME=afvb & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvn ImageHandle arg_8h
afvn SystemTable arg_ch
afvb~?ImageHandle
afvb~?SystemTable
EOF
RUN

NAME=afvb* & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvn ImageHandle arg_8h
afvn SystemTable arg_ch
afvb*~?ImageHandle
afvb*~?SystemTable
EOF
RUN

NAME=afvb idx... & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
afvb 8 ImageHandle blah @ 0x10002d8d
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvb*~ImageHandle
EOF
RUN

NAME=afvbj
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvbj~?ImageHandle
EOF
RUN

NAME=afvb-ArgName
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvb-ImageHandle
afvb~?ImageHandle
EOF
RUN

NAME=afvr & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr~?myreg
afvn blah myreg
afvr~?blah
EOF
RUN

NAME=afvr idx & afvr*
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr*~?myreg
afvr*~?int
EOF
RUN

NAME=afvr-name
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr-myreg
afvr~?myreg
EOF
RUN

NAME=afvb-* afvr-*
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
0
EOF
CMDS=<<EOF
af
afvb-*
afvr-*
afvb~?
afvr~?
EOF
RUN

NAME=anal vars count
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
13
EOF
CMDS=<<EOF
af
afvb~?
EOF
RUN

NAME=anal vars retype
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
var char var_30h @ rbp-0x30
EOF
CMDS=<<EOF
af
afvt var_30h char
afvb~_30h
EOF
RUN

NAME=anal vars rename
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
var int newname @ rbp-0x30
EOF
CMDS=<<EOF
af
afvn newname var_30h
afvb~newname
EOF
RUN

NAME=vars commenting
FILE=malloc://1024
EXPECT=<<EOF
|           ; arg int var_8h @ rbp+0x8    ; comment
EOF
CMDS=<<EOF
af
afvb 8 var_8h int
Cvb 0x8 comment
pd1~comment
EOF
RUN

NAME=vars display in debugger
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
pxr $w @ebp+0xc
pxr $w @ebp-0x10
EOF
CMDS=<<EOF
aa
s 0x0804843b
afvd arg_ch
afvd var_10h
EOF
RUN

NAME=afvR and afvW test
FILE=../bins/elf/crackme0x05
EXPECT=<<EOF

   var_78h  0x8048577,0x804858a
    var_4h  
   var_78h  
    var_4h  0x804857a
EOF
CMDS=<<EOF
aa
s main
?e
afvR
afvW
EOF
RUN

NAME=axt avr
FILE=../bins/firmware/main.avr
EXPECT=<<EOF
            ; DATA XREF from str.hello ()
            0x00000260      80e0           ldi r24, 0x00
EOF
CMDS=<<EOF
f str.hello 12 @ 0x276
Csa 12 @ str.hello
axd 0x260 @ str.hello
pd 1 @ 0x260
EOF
RUN

NAME=axt capstone x86
FILE=../bins/elf/analysis/main
EXPECT=<<EOF
sym.main 0x40050a [DATA] mov edi, str.Hello_World
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color=false
e scr.wheel = false
aa
axt @ str.Hello_World
EOF
RUN

NAME=axt capstone x86: IOLI0
FILE=../bins/elf/ioli/crackme0x00
EXPECT=<<EOF
main 0x804843c [DATA] mov dword [esp], str.Password:
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color=false
e scr.wheel = false
aa
axt @ str.Password:
EOF
RUN

NAME=axt capstone x86: IOLI7 aa
FILE=../bins/elf/ioli/crackme0x07
EXPECT=<<EOF
sub.Password_Incorrect_8048524 0x804853d [CALL] call sym.imp.exit
sub.sscanf_8048542 0x80485ab [CALL] call sym.imp.exit
sub.strlen_80485b9 0x804866f [CALL] call sym.imp.exit
EOF
CMDS=<<EOF
aaa
axt @ sym.imp.exit
EOF
RUN

NAME=axt capstone x86: IOLI7 aa
FILE=../bins/elf/ioli/crackme0x07
EXPECT=<<EOF
sub.Password_Incorrect_8048524 0x804853d [CALL] call sym.imp.exit
sub.sscanf_8048542 0x80485ab [CALL] call sym.imp.exit
sub.strlen_80485b9 0x804866f [CALL] call sym.imp.exit
EOF
CMDS=<<EOF
aaaa
axt @ sym.imp.exit
EOF
RUN

NAME=axt respect relsub
FILE=../bins/pe/ibknoreloc64.exe
EXPECT=<<EOF
entry0 0xffffffffffff100a [CALL] call qword [rip + 0xd8]
entry0 0xffffffffffff100a [CALL] call qword sym.imp.msvcrt.dll_printf
EOF
CMDS=<<EOF
aaa
e asm.relsub=false
axt @ sym.imp.msvcrt.dll_printf
e asm.relsub=true
axt @ sym.imp.msvcrt.dll_printf
EOF
RUN

NAME=ax-
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
EOF
CMDS=<<EOF
ax 10 20
axq
ax-10 20
axq
EOF
RUN

NAME=ax-@
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
EOF
CMDS=<<EOF
s 20
ax 10
axq
ax-10
axq
EOF
RUN

NAME=ax-*
FILE=-
EXPECT=<<EOF
                                       ? 0x0 ->   UNKNOWN -> 0xa
EOF
CMDS=<<EOF
ax 10
ax
ax-*
ax
EOF
RUN

NAME=axt unknown function
FILE=../bins/pe/lab11.malware
EXPECT=<<EOF
(nofunc) 0x401a1d [CALL] call fcn.00401270
EOF
CMDS=<<EOF
aaa
axt fcn.00401270
EOF
RUN

NAME=axf string ref capstone x86
FILE=../bins/elf/ioli/crackme0x03
EXPECT=<<EOF
sym.test 0x804848a [DATA] mov dword [esp], str.Sdvvzrug_RN
d 0x804848a mov dword [esp], str.Sdvvzrug_RN
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color = false
e scr.wheel = false
aa
axt str.Sdvvzrug_RN
axf 0x804848a
EOF
RUN

NAME=x86 ref issue
FILE=-
EXPECT=<<EOF
0x00004434
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch=x86
wx c7052a44000050000000
ao~^ptr[1]
EOF
RUN

NAME=strings xref issue
FILE=../bins/elf/redpill
EXPECT=<<EOF
main 0x1457 [STRING] lea eax, str.Take_the_Red_Pill
main 0x148e [STRING] lea eax, str.use:_._exploit1_PILL
main 0x14eb [STRING] lea eax, str.Red_Pill__0x50444552
main 0x1502 [STRING] lea eax, str.Your_Pill_0x_08x
main 0x1523 [STRING] lea eax, str.Red_Pill
main 0x1557 [STRING] lea eax, str.fwhibbit
main 0x161d [STRING] lea eax, str.Blue_Pill
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
axt 0x00001d89
axt 0x00001da0
axt 0x00001db7
axt 0x00001dd1
axt 0x00001de8
axt 0x00001df4
axt 0x00001e09
EOF
RUN

NAME=reference to like mov [0x400000], 0x1234
FILE=../bins/elf/analysis/reference.out
EXPECT=<<EOF
sym.main 0x80483ee [DATA] mov dword obj.a, 0x1337
EOF
CMDS=<<EOF
aaa
axt@0x0804a01c
EOF
RUN

NAME=delete references with ax-
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
0x00000014 -> 0x0000000a  UNKNOWN
0x00000028 -> 0x0000001e  UNKNOWN
EOF
CMDS=<<EOF
ax 10 20
axq
ax- 10
axq
ax 10 20
ax 30 40
axq
ax-*
axq
EOF
RUN

NAME=reference PIC binary
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
main 0x8048432 [STRING] lea eax, str.Hello_PIC
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
axt@0x80484e0
EOF
RUN

NAME=strings xref issue without relsub
FILE=../bins/elf/redpill
EXPECT=<<EOF
main 0x1457 [STRING] lea eax, [esi - 0x2277]
main 0x148e [STRING] lea eax, [esi - 0x2260]
main 0x14eb [STRING] lea eax, [esi - 0x2249]
main 0x1502 [STRING] lea eax, [esi - 0x222f]
main 0x1523 [STRING] lea eax, [esi - 0x2218]
main 0x1557 [STRING] lea eax, [esi - 0x220c]
main 0x161d [STRING] lea eax, [esi - 0x21f7]
EOF
CMDS=<<EOF
e anal.strings=true
e asm.relsub=false
aa
aae
axt 0x00001d89
axt 0x00001da0
axt 0x00001db7
axt 0x00001dd1
axt 0x00001de8
axt 0x00001df4
axt 0x00001e09
EOF
RUN

NAME=reference PIC binary without relsub
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
main 0x8048432 [STRING] lea eax, [ebx - 0x1b20]
EOF
CMDS=<<EOF
e anal.strings=true
e asm.relsub=false
aa
aae
axt@0x80484e0
EOF
RUN

NAME=refs on PIC binary disassembly
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
|           0x08048432      8d83e0e4ffff   lea eax, str.Hello_PIC      ; 0x80484e0 ; "Hello PIC!"
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
pd 1 @ 0x08048432
EOF
RUN

NAME=refs on PIC binary disassembly (color)
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
[36m|[0m [36m          [0m[32m0x08048432[0m      [37mlea[36m eax[0m,[36m [0m[33mstr.Hello_PIC[0m[36m[0m[0m
EOF
CMDS=<<EOF
e asm.bytes=false
e asm.comments=false
e scr.color=1
e anal.strings=true
aa
aae
pd 1 @ 0x08048432
EOF
RUN

NAME=axs
FILE=-
EXPECT=<<EOF
0x00000000 -> 0x00000010  STRING
EOF
CMDS=<<EOF
axs 0x10
axq
EOF
RUN

NAME=refs with aar
FILE=../bins/elf/crackme
EXPECT=<<EOF
;-- __libc_csu_fini:
; DATA XREF from entry0 (+0xf)
0x00400730      f3c3           ret
; CODE XREF from sym.__do_global_ctors_aux (+0x2d)
0x004007f0      4883eb08       sub rbx, 8
;-- __do_global_dtors_aux:
; CALL XREF from section..fini (+0x4)
0x00400610      55             push rbp
EOF
CMDS=<<EOF
e asm.lines.bb=false
e asm.lines.fcn=false
aar
pd 1 @0x400730
pd 1 @0x4007f0
pd 1 @0x400610
EOF
RUN

NAME=refs with afr
FILE=../bins/elf/crackme
EXPECT=<<EOF
(fcn) sym.__libc_csu_fini 2
  sym.__libc_csu_fini ();
; DATA XREF from entry0 (0x4005cf)
0x00400730      f3c3           ret
; CODE XREF from sym.__do_global_ctors_aux (0x4007fd)
0x004007f0      4883eb08       sub rbx, 8
(fcn) sym.__do_global_dtors_aux 100
  sym.__do_global_dtors_aux ();
; CALL XREF from sym._fini (0x40080c)
0x00400610      55             push rbp
EOF
CMDS=<<EOF
e asm.lines.bb=false
e asm.lines.fcn=false
e anal.cjmpref=true
aa
afr
pd 1 @0x400730
pd 1 @0x4007f0
pd 1 @0x400610
EOF
RUN

NAME=cjmp data refs with aar
FILE=malloc://10000
EXPECT=<<EOF
; DATA XREF from unk ()
0x1000002e      00             nop
EOF
CMDS=<<EOF
e asm.arch=8051
e asm.lines.bb=false
e asm.lines.fcn=false
wx 307401000022
aar
pd 1 @_idata+0x2e
EOF
RUN

NAME=cjmp data refs with afr
FILE=malloc://10000
EXPECT=<<EOF
; DATA XREF from fcn.00000000 ()
0x1000002e      00             nop
EOF
CMDS=<<EOF
e asm.arch=8051
e asm.lines.bb=false
e asm.lines.fcn=false
wx 307401000022
aa
afr
pd 1 @_idata+0x2e
EOF
RUN

NAME=xtensa stackframe
FILE=malloc://512
EXPECT=<<EOF
var int var_4h @ a1+0x4
var int var_8h @ a1+0x8
var int var_ch @ a1+0xc
EOF
CMDS=<<EOF
e asm.arch=xtensa
e asm.bits=32
wx 12c1f0d91140d382c9213d0d093101f5ebc00000cd028c820c034d0d0112e4c0000008312d0cd811c82112c1100df0
af
afvs
EOF
RUN

NAME=xrefs and overlapping basic blocks
FILE=../bins/elf/analysis/ls-linux-x86_64-zlul
CMDS=<<EXPECT
aaa
axt main
EXPECT=<<RUN
entry0 0x40488d [DATA] mov rdi, main
RUN

NAME=unique function names
FILE=../bins/elf/bash
CMDS=<<EXPECT
aaa
f~strlen~390
EXPECT=<<RUN
0x00060390 732 sub.strlen_60390
0x0006d390 197 sub.strlen_6d390
RUN

NAME=no function split without overlapping blocks
FILE=../bins/elf/libc.so.6
CMDS=<<EXPECT
aac
s 0x2254d
agf~invalid
echo end
EXPECT=end
RUN

NAME=noreturn of reloc-functions
FILE=../bins/elf/ls
CMDS=<<EXPECT
aaa
afbr 0x80b0
EXPECT=<<RUN
0x000081cb
0x00008237
RUN
