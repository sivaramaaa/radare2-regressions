NAME=x86_64 socket syscall
FILE=../bins/mach0/ls-osx-x86_64
CMDS=<<EOF
af
aCe 0x10000143e
EOF
EXPECT=<<EOF
char *getenv("COLUMNS")
EOF
RUN

NAME=x86_64 socket syscall
FILE=../bins/elf/socket-syscall
CMDS=<<EOF
aa
aae
s main
pd 1 @0x00001140
aei
aeim
aecu 0x00001140
as
EOF
EXPECT=<<EOF
|           ;-- syscall.socket:
|           ;-- syscall.socket.0:
|           ;-- syscall.socket.1:
|           ;-- syscall.socket.2:
|           0x00001140      0f05           syscall
41 = socket (0x00000001, 0x00000002, 0x00000003)
EOF
RUN

NAME=x86_64 jmptbl -O0
FILE=../bins/mach0/FMS.uu
CMDS=<<EOF
s sym._checkinput
af
afi*
EOF
EXPECT=<<EOF
"f sym._checkinput 288 0x100000da0"
"af+ 0x100000da0 sym._checkinput f n"
afc amd64 @ 0x100000da0
afb+ 0x100000da0 0x100000da0 22 0x100000db6 0xffffffffffffffff b
afb+ 0x100000da0 0x100000db6 26 0x100000e99 0x100000dd0 n
afb+ 0x100000da0 0x100000dd0 20 0xffffffffffffffff 0xffffffffffffffff n
afb+ 0x100000da0 0x100000de4 16 0x100000dfb 0x100000df4 n
afb+ 0x100000da0 0x100000df4 7 0x100000dfb 0xffffffffffffffff n
afb+ 0x100000da0 0x100000dfb 5 0x100000e99 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e00 16 0x100000e1c 0x100000e10 n
afb+ 0x100000da0 0x100000e10 12 0x100000e25 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e1c 9 0x100000eba 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e25 5 0x100000e99 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e2a 16 0x100000e46 0x100000e3a n
afb+ 0x100000da0 0x100000e3a 12 0x100000e4f 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e46 9 0x100000eba 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e4f 5 0x100000e99 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e54 16 0x100000e82 0x100000e64 n
afb+ 0x100000da0 0x100000e64 16 0x100000e82 0x100000e74 n
afb+ 0x100000da0 0x100000e74 14 0x100000e8b 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e82 9 0x100000eba 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e8b 5 0x100000e99 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e90 9 0x100000eba 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e99 5 0x100000e9e 0xffffffffffffffff n
afb+ 0x100000da0 0x100000e9e 24 0x100000db6 0x100000eb6 n
afb+ 0x100000da0 0x100000eb6 4 0x100000eba 0xffffffffffffffff b
afb+ 0x100000da0 0x100000eba 6 0xffffffffffffffff 0xffffffffffffffff n
afvb -40 var_28h int32_t @ 0x100000da0
afvb -32 var_20h int32_t @ 0x100000da0
afvb -24 var_18h int32_t @ 0x100000da0
afvb -20 var_14h int32_t @ 0x100000da0
afvb -16 var_10h int32_t @ 0x100000da0
afvb -1 var_1h int32_t @ 0x100000da0
afvr rdi arg1 int32_t @ 0x100000da0
axd 0x100000ec0 0x100000dd0
axc 0x100000de4 0x100000de2
axc 0x100000e00 0x100000de2
axc 0x100000e2a 0x100000de2
axc 0x100000e54 0x100000de2
axc 0x100000e90 0x100000de2
axc 0x100000e99 0x100000dfb
axc 0x100000e25 0x100000e17
axc 0x100000eba 0x100000e20
axc 0x100000e99 0x100000e25
axc 0x100000e4f 0x100000e41
axc 0x100000eba 0x100000e4a
axc 0x100000e99 0x100000e4f
axc 0x100000e8b 0x100000e7d
axc 0x100000eba 0x100000e86
axc 0x100000e99 0x100000e8b
axc 0x100000eba 0x100000e94
axc 0x100000e9e 0x100000e99
afS 8 @ 0x100000da0

EOF
RUN

NAME=aac pe trampoline fcn name 64bit
FILE=../bins/pe/testx64.exe
CMDS=<<EXPECT
e anal.autoname=false
aac
pd 1 @ 0x140001970
EXPECT=<<RUN
|           0x140001970      e8d1040000     call sub.KERNEL32.dll_IsProcessorFeaturePresent ; BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
RUN

NAME=a2f jmp after ret
FILE=malloc://512
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
EOF
RUN

NAME=a2f jmp after ret - _size (symsize)
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
afl~[2]
EOF
RUN

NAME=a2f jmp after ret - realsize (bbs_sum)
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
afl~[2]
EOF
RUN

NAME=aaa with avra
FILE=../bins/elf/class_test
EXPECT=<<EOF
VMI Type Info at 0x08048f4c:
  Reference to RTTI's type class: 0x0804b140
  Reference to type's name: 0x08048f6c
  Type Name: Bat
  Flags: 0x0
  Count of base classes: 0x2
      Base class type descriptor address: 0x08048f74
      Base class flags: 0x2
      Base class type descriptor address: 0x08048fac
      Base class flags: 0x402

VMI Type Info at 0x08048f4c:
  Reference to RTTI's type class: 0x0804b140
  Reference to type's name: 0x08048f6c
  Type Name: Bat
  Flags: 0x0
  Count of base classes: 0x2
      Base class type descriptor address: 0x08048f74
      Base class flags: 0x2
      Base class type descriptor address: 0x08048fac
      Base class flags: 0x402

Type Info at 0x08048f74:
  Reference to RTTI's type class: 0x0804b048
  Reference to type's name: 0x08048f7c
  Type Name: Bird

SI Type Info at 0x08048f84:
  Reference to RTTI's type class: 0x0804b114
  Reference to type's name: 0x08048f90
  Type Name: Dog
  Reference to parent's type name: 0x08048fac

SI Type Info at 0x08048f98:
  Reference to RTTI's type class: 0x0804b114
  Reference to type's name: 0x08048fa4
  Type Name: Cat
  Reference to parent's type name: 0x08048fac

Type Info at 0x08048fac:
  Reference to RTTI's type class: 0x0804b048
  Reference to type's name: 0x08048fb4
  Type Name: Mammal

EOF
CMDS=<<EOF
aaa
avra
EOF
RUN

NAME=aac on mips be
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1268
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac with maps (less because of wrong map address)
FILE=../bins/elf/analysis/mipsbe-busybox
ARGS=-n -m 0x80000 -a mips -b32 -e cfg.bigendian=true
EXPECT=<<EOF
4
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac (using a PIC bin)
BROKEN=1
FILE=../bins/elf/libmagic.so
EXPECT=<<EOF
202
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac with maps (using a PIC bin)
BROKEN=1
FILE=../bins/elf/libmagic.so
ARGS=-n -m 0x80000 -a arm -b 16 -e cfg.bigendian=false
EXPECT=<<EOF
96
EOF
CMDS=<<EOF
aac
e search.in=io.maps
afl~?
EOF
RUN

NAME=aav without vinfun
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af @ 0x0040dea4
e anal.vinfun=false
aav
pd 1 @ 0x0040decc~?andi
EOF
RUN

NAME=aav with vinfun
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af @ 0x0040dea4
e anal.vinfun=true
aav
pd 1 @ 0x0040decc~?dword
EOF
RUN

NAME=aav thumb detection
FILE=../bins/firmware/armthumb.bin
ARGS=-aarm -b32
EXPECT=<<EOF
0x0000000d 4 aav.0x0000000d
EOF
CMDS=<<EOF
aav
f
EOF
RUN


NAME=sym is not fcn
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
EOF
CMDS=<<EOF
aa > /dev/null
afl~sym.__mh_execute_header[0]
EOF
RUN


NAME=call-convention
FILE=../bins/elf/analysis/x86-simple
EXPECT=<<EOF
call-convention: stdcall
EOF
CMDS=<<EOF
aa
s entry0
afc stdcall
afi~call-convention
EOF
RUN

NAME=function address
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f50
0x00001f00
EOF
CMDS=<<EOF
e anal.hasnext=0
aa
afo sym._foo
afo sym._bar
EOF
RUN

NAME=afr
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f80    1 41           main
0x00001f50    1 47           sym._foo
0x00001f00    4 73           sym._bar
EOF
CMDS=<<EOF
e anal.hasnext=0
afr
afl
EOF
RUN

NAME=aF
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f80    1 41           main
EOF
CMDS=<<EOF
e anal.hasnext=0
aF
afl
EOF
RUN

NAME=function prelude offsets
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00
0x00001f50
0x00001f80
EOF
CMDS=<<EOF
s 0x1000
aap
afl~[0]
EOF
RUN

NAME=function preludes symbol names
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00    4 73           sym._bar
0x00001f50    1 47           sym._foo
0x00001f80    1 41           main
EOF
CMDS=<<EOF
s 0x1000
aap
afl
EOF
RUN


NAME=af-*
FILE=../bins/elf/analysis/main
EXPECT=<<EOF
EOF
CMDS=<<EOF
aa
af-*
afl
EOF
RUN

NAME=iS. and iSj. implementation
FILE=../bins/elf/lab1B
EXPECT='Current section
Nm Paddr       Size Vaddr      Memsz Perms Checksum          Name
00 0x00000188    36 0x08048188    36 -r-- .note.gnu.build_id
Current section
Nm Paddr       Size Vaddr      Memsz Perms Checksum          Name
{"name":".plt","size":240,"vsize":240,"perm":"-r-x","paddr":1888,"vaddr":134514528}'
CMDS=<<EOF
s 0x188
iS.
s 0x08058000
iS.
s 0x760
iSj.
EOF
RUN

NAME=iE and iE. implementation
FILE=../bins/elf/lab1B
EXPECT='Num Paddr      Vaddr      Bind     Type Size Name
022 0x000009b7 0x080489b7 GLOBAL   FUNC  189 decrypt
{"name":"prog_timeout","demname":"","flagname":"sym.prog_timeout","ordinal":35,"bind":"GLOBAL","size":17,"type":"FUNC","vaddr":134515110,"paddr":2470}'
CMDS=<<EOF
s 0x080489b9
iE.
s 0x080489a6
s+5
isj.
EOF
RUN

NAME=address information
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
exec
read
flag
flag
EOF
CMDS=<<EOF
s entry0
ai
s sym.__mh_execute_header
ai
EOF
RUN

NAME=af x86-64
FILE=malloc://16
EXPECT=<<EOF
10
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
wx 662e0f1f840000000000
ao 1~size[1]
EOF
RUN

NAME=anal/fcn_name
FILE=../bins/elf/analysis/main-g
EXPECT=<<EOF
/ (fcn) sym.call_gmon_start 23
EOF
CMDS=<<EOF
s 0x0040042c
af
pd 1~sym.call_gmon_start:0
EOF
RUN

NAME=anal/fcn_subname
FILE=../bins/elf/analysis/main-g
EXPECT=<<EOF
name: sym.call_gmon_start
/ (fcn) sym.call_gmon_start 23
EOF
CMDS=<<EOF
s 0x0040042c
af
afi~name
pd 1~sym.call_gmon_start:0
EOF
RUN

NAME=anal/name
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
name: main
EOF
CMDS=<<EOF
af
afi~name
EOF
RUN

NAME=anal hasnext on main
FILE=../bins/elf/true32
EXPECT=<<EOF
size: 261
EOF
CMDS=<<EOF
e anal.hasnext=true
af@main
afi@main~size
EOF
RUN

NAME=anal without hasnext on main
FILE=../bins/elf/true32
EXPECT=<<EOF
size: 261
EOF
CMDS=<<EOF
e anal.hasnext=false
af@main
afi@main~size
EOF
RUN

NAME=ahe
FILE=malloc://512
EXPECT=<<EOF
15
esil: test
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch = x86
e anal.arch = x86
ao~?
ahe test
ao~esil
EOF
RUN

NAME=ahe2
FILE=malloc://512
EXPECT=<<EOF
esil: test
EOF
CMDS=<<EOF
ahe test
ao~^esil
EOF
RUN

NAME=ahe 33,rax,=
FILE=malloc://512
EXPECT=<<EOF
0x00000021
EOF
CMDS=<<EOF
wx 000000
ahe 33,rax,=
aes
dr?rax
EOF
RUN

NAME=delete memory format with Cf-
FILE=../bins/dmg/src/Hello
EXPECT=<<EOF
            0x00000000      57             push rdi
            0x00000000 pf x # size=1
0x00000000 = 0x6c726f57
temp_proj
            0x00000000      57             push rdi
temp_proj
            0x00000000      57             push rdi
EOF
CMDS=<<EOF
pd 1
Cf 1 x
pd 1
Ps temp_proj
Cf-
pd 1
Ps temp_proj
Po temp_proj
pd 1
EOF
RUN




NAME=reflines offset 2 (ascii)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|       ,=< 0x000113bd      je 0x1144e
|       |   0x000113c3      mov esi, 0x2f                              ; '/' ; int c
|       |   0x000113c8      call sym.imp.strrchr                       ; char *strrchr(const char *s, int c)
|       |   0x000113cd      test rax, rax
|      ,==< 0x000113d0      je 0x11424
|      ||   0x000113d2      lea rdx, [rax + 1]                         ; r10 ; "ELF\x02\x01\x01"
|      ||   0x000113d6      mov rcx, rdx
|      ||   0x000113d9      sub rcx, rbx
|      ||   0x000113dc      cmp rcx, 6
|     ,===< 0x000113e0      jle 0x11424
|     |||   0x000113e2      lea rsi, [rax - 6]
|     |||   0x000113e6      mov ecx, 7
|     |||   0x000113eb      lea rdi, [rip + 0x7ebb]                    ; str..libs ; 0x192ad ; "/.libs/"
|     |||   0x000113f2      repe cmpsb byte [rsi], byte ptr [rdi]
|    ,====< 0x000113f4      jne 0x11424
|    ||||   0x000113f6      mov ecx, 3
|    ||||   0x000113fb      mov rsi, rdx
|    ||||   0x000113fe      mov rbx, rdx
|    ||||   0x00011401      lea rdi, [rip + 0x7ead]                    ; "lt-" ; 0x192b5
|    ||||   0x00011408      repe cmpsb byte [rsi], byte ptr [rdi]
|    ||||   0x0001140a      seta sil
|    ||||   0x0001140e      setb cl
|    ||||   0x00011411      cmp sil, cl
|   ,=====< 0x00011414      jne 0x11424
|   |||||   0x00011416      lea rbx, [rax + 4]
|   |||||   0x0001141a      mov rax, qword [rip + 0xdeaf]; MOV rax = [0x1f2d0] = 0x0 r9
 ; reloc.program_invocation_short_name ; [0x1f2d0:8]=0
|   |||||   0x00011421      mov qword [rax], rbx
|   |||||   ; CODE XREFS from fcn.00011390 (0x113d0, 0x113e0, 0x113f4, 0x11414)
|   ````--> 0x00011424      mov rax, qword [rip + 0xde3d]; MOV rax = [0x1f268] = 0x21680 
 ; [0x1f268:8]=0x21680
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
s $S
aaa >/dev/null
s 0x000113bd
pd 28
EOF
RUN

NAME=reflines offset 3 (ascii)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|       ,=< 0x00003ca9      je 0x45ec
|       |   0x00003caf      cmp eax, 3
|      ,==< 0x00003cb2      je 0x3ce3
|      ||   0x00003cb4      sub eax, 1
|     ,===< 0x00003cb7      je 0x3cbe
|     |||   ; CODE XREF from main (0x58bc)
|     |||   0x00003cb9      call sym.imp.abort                         ; void abort(void)
|     |||   ; CODE XREF from main (0x3cb7)
|     `---> 0x00003cbe      mov edi, 1                                 ; int fd
|      ||   0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|      ||   0x00003cc8      test eax, eax
|     ,===< 0x00003cca      je 0x4c2e
|     |||   0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|     |||   0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
|    ,====< 0x00003ce1      jmp 0x3cf9
|    ||||   ; CODE XREF from main (0x3cb2)
|    ||`--> 0x00003ce3      mov esi, 5
|    || |   0x00003ce8      xor edi, edi
|    || |   0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|    || |   0x00003cf4      call fcn.00012740
|    || |   ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
|    `----> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
s $S
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines offset 3 (ascii + wide)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|      ,==< 0x00003ca9      je 0x45ec
|      |    0x00003caf      cmp eax, 3
|    ,====< 0x00003cb2      je 0x3ce3
|    | |    0x00003cb4      sub eax, 1
|  ,======< 0x00003cb7      je 0x3cbe
|  | | |    ; CODE XREF from main (0x58bc)
|  | | |    0x00003cb9      call sym.imp.abort                         ; void abort(void)
|  | | |    ; CODE XREF from main (0x3cb7)
|  `------> 0x00003cbe      mov edi, 1                                 ; int fd
|    | |    0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|    | |    0x00003cc8      test eax, eax
|  ,======< 0x00003cca      je 0x4c2e
|  | | |    0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|  | | |    0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
| ========< 0x00003ce1      jmp 0x3cf9
|  | | |    ; CODE XREF from main (0x3cb2)
|  | `----> 0x00003ce3      mov esi, 5
|  |   |    0x00003ce8      xor edi, edi
|  |   |    0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|  |   |    0x00003cf4      call fcn.00012740
|  |   |    ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
| --------> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
s $S
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines offset 4 (ascii + wide)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|      ,==< 0x00003ca9      je 0x45ec
|      |    0x00003caf      cmp eax, 3
|    ,====< 0x00003cb2      je 0x3ce3
|    | |    0x00003cb4      sub eax, 1
|  ,======< 0x00003cb7      je 0x3cbe
|  | | |    ; CODE XREF from main (0x58bc)
|  | | |    0x00003cb9      call sym.imp.abort                         ; void abort(void)
|  | | |    ; CODE XREF from main (0x3cb7)
|  `------> 0x00003cbe      mov edi, 1                                 ; int fd
|    | |    0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|    | |    0x00003cc8      test eax, eax
|  ,======< 0x00003cca      je 0x4c2e
|  | | |    0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|  | | |    0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
| ========< 0x00003ce1      jmp 0x3cf9
|  | | |    ; CODE XREF from main (0x3cb2)
|  | `----> 0x00003ce3      mov esi, 5
|  |   |    0x00003ce8      xor edi, edi
|  |   |    0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|  |   |    0x00003cf4      call fcn.00012740
|  |   |    ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
| --------> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines in noreturn
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
/ (fcn) fcn.00012740 76
|   fcn.00012740 (int32_t arg1, int32_t arg2);
|           ; var int32_t var_8h @ rbp-0x8
|           ; arg int32_t arg1 @ rdi
|           ; arg int32_t arg2 @ rsi
|           0x00012740      push rbp
|           0x00012741      mov rbp, rsp
|           0x00012744      sub rsp, 0x1030
|           0x0001274b      or qword [rsp], 0
|           0x00012750      add rsp, 0x1020
|           0x00012757      mov rax, qword fs:[0x28]
|           0x00012760      mov qword [var_8h], rax
|           0x00012764      xor eax, eax
|           0x00012766      lea rax, [rip + 0xf033]
|           0x0001276d      test rdi, rdi
|           0x00012770      cmovne rax, rdi
|           0x00012774      mov dword [rax], esi
|           0x00012776      mov rax, qword [var_8h]
|           0x0001277a      xor rax, qword fs:[0x28]
|      ,==< 0x00012783      jne 0x12787
|      |    0x00012785      leave
|      |    0x00012786      ret
\      `--> 0x00012787      call sym.imp.__stack_chk_fail
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
e asm.comments=0
aaa >/dev/null
s 0x00012740
pdf
EOF
RUN

NAME=⁝ and XREF cmt
FILE=../bins/elf/strenc-ctrlchars
EXPECT=<<EOF

┌ (fcn) sym.imp.puts 6
│   int sym.imp.puts (const char *s);
│       ╎   ; CALL XREF from main (0x400406)
└       ╎   0x004003f0      jmp qword reloc.puts                       ; [0x601018:8]=0x4003f6
        ╎   0x004003f6      push 0
        └─< 0x004003fb      jmp sym..plt
EOF
CMDS=<<EOF
e scr.utf8=true
e asm.bytes=false
s main
af
s sym.imp.puts
?e
pd 3
EOF
RUN

NAME=stackptr
FILE=../bins/mach0/mac-ls
EXPECT=<<EOF
104
104
48-
40-
32-
24-
16-
8-
EOF
CMDS=<<EOF
s 0x1000039b6
af
e asm.lines.bb=false
e asm.lines.fcn=false
e asm.stackptr=true
pdr~0x100003b27[1]
pdf~0x100003b27[1]
pdr~0x100003b3d[1]
pdr~0x100003b3e[1]
pdr~0x100003b40[1]
pdr~0x100003b42[1]
pdr~0x100003b44[1]
pdr~0x100003b46[1]
EOF
RUN

NAME=auto string memory reference (iopa)
FILE=malloc://8096
EXPECT=<<EOF
; MOV rsi = [0x1048] = 0x500 
  ; [0x1048:8]=0x500 "Hello"
  0x00000000      mov rsi, qword [rip + 0x1041]
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.arch = x86
e asm.bits=64
e scr.color = false
e io.va=0
e asm.lines.bb=0
e asm.bytes=0
e asm.cmt.right=10
wx 488b3541100000
wv8 0x500 @ 0x1048
w Hello @ 0x500
pd 1
EOF
RUN

NAME=auto string memory reference (io.va)
FILE=malloc://8096
EXPECT=<<EOF
; MOV rsi = [0x1048] = 0x500 
  ; [0x1048:8]=0x500 "Hello"
  0x00000000      mov rsi, qword [rip + 0x1041]
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.arch = x86
e asm.bits=64
e scr.color = false
e io.va=1
e asm.lines.bb=0
e asm.bytes=0
e asm.cmt.right=10
wx 488b3541100000
wv8 0x500 @ 0x1048
w Hello @ 0x500
pd 1
EOF
RUN


NAME=no string on cbz
FILE=malloc://8096
EXPECT=<<EOF
            0x00000000      15008052       movz w21, 0
        ,=< 0x00000004      b5000034       cbz w21, 0x18               ; likely
EOF
CMDS=<<EOF
e asm.arch=arm
e asm.bits=64
e cfg.bigendian=false
e emu.str=true
wv 0x52800015
wv 0x340000b5 @ 4
w hello @ 0x18
pd 2
EOF
RUN

NAME=No function
FILE=malloc://0x50
EXPECT=<<EOF
EOF
CMDS=<<EOF
aftm
EOF
RUN

NAME=Basic type Matching
FILE=../bins/elf/analysis/x86-helloworld-gcc
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
s sym.main
aa
aei
aeim
td int puts(char *s);
aft
s 0x08048409
pd 1~char *s?
EOF
RUN

NAME=call not function
FILE=../bins/pe/crackme0x00.exe
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
aa
s sym._main
aei
aeim
td int strcmp(char *s1, char *s2);
tk func.strcmp.cc=stdcall
aft
s 0x00401368
pd 1~char *s1?
s 0x00401370
pd 1~char *s2?
EOF
RUN

NAME=Settings global calling convention
FILE=../bins/pe/msvcfindmain.exe
EXPECT=<<EOF
65
EOF
CMDS=<<EOF
afc=pascal
aaa
afi @@@F~?pascal
EOF
RUN

NAME=1: Wrong calling convention
FILE=../bins/pe/crackme0x00.exe
EXPECT=<<EOF
EOF
CMDS=<<EOF
s entry0
af
tk CRTStartup=func
tk func.CRTStartup.args=1
tk func.CRTStartup.arg0= int,who_cares
tk func.CRTStartup.cc=THE_CC_THAT_NEVER_EXISTED
tk func.CRTStartup.ret=eax
aei
aeim
aftm
EOF
RUN

NAME=2: Wrong calling convention
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
int category
int fd
unsigned long request
EOF
CMDS=<<EOF
s entry0
aaa
afta
Ct. @ 0x100001413
Ct. @ 0x10000145b
Ct. @ 0x100001460
EOF
RUN

NAME=Function definition
FILE=../bins/elf/arm1.bin
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
afr @ main
s 0x000082cc
pd 1~?*xmalloc
EOF
RUN

NAME=Function definition (autorename)
FILE=../bins/pe/hello-mingw32
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
s 0x00401255
pd 1~?ExitProcess(UINT
EOF
RUN

NAME=Function definition indirect calls
FILE=.../bins/pe/msvcfindmain.exe
BROKEN=1
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
pd 1 @ 0x004012c0 ~?DWORD
EOF
RUN

NAME=Function definition
FILE=../bins/elf/ioli/crackme0x00
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
s 0x08048469
pd 1~?strcmp(const
EOF
RUN

NAME=afvt
FILE=../bins/mach0/arg
EXPECT=<<EOF
var int32_t var_14h @ rbp-0x14
var int32_t var_10h @ rbp-0x10
var int32_t var_8h @ rbp-0x8
arg int32_t arg1 @ rdi
arg int32_t arg2 @ rsi
EOF
CMDS=<<EOF
s sym._call
af
afv
EOF
RUN

NAME=afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int32_t var_30h @ rbp-0x30
var char var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afv~var_30h
EOF
RUN

NAME=afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int32_t var_30h @ rbp-0x30
var int32_t mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afv~mylocal
EOF
RUN

NAME=afvn + afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int32_t var_30h @ rbp-0x30
var int32_t var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afvn var_30h mylocal
afv~var_30h
EOF
RUN

NAME=afvt + afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int32_t var_30h @ rbp-0x30
var char mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afvt mylocal char
afv~mylocal
EOF
RUN

NAME=afvn + afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int32_t var_30h @ rbp-0x30
var char mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afvn mylocal var_30h
afv~mylocal
EOF
RUN

NAME=afvt + afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int32_t var_30h @ rbp-0x30
var int var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afvt var_30h int
afv~var_30h
EOF
RUN


NAME=afva for fastcall with no esp vars
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
fastcall
/ (fcn) sym.fastcaslled 59
|   sym.fastcaslled (int32_t arg2, int32_t arg1, int32_t arg_8h, int32_t arg_ch);
|           ; var int32_t var_20h @ ebp-0x20
|           ; var int32_t var_1ch @ ebp-0x1c
|           ; var int32_t var_10h @ ebp-0x10
|           ; var int32_t var_ch @ ebp-0xc
|           ; arg int32_t arg_8h @ ebp+0x8
|           ; arg int32_t arg_ch @ ebp+0xc
|           ; arg int32_t arg2 @ edx
|           ; arg int32_t arg1 @ ecx
|           ; CALL XREF from main (0x80484c7)
|           0x0804841b      55             push ebp
|           0x0804841c      89e5           mov ebp, esp
|           0x0804841e      83ec28         sub esp, 0x28               ; '('
|           0x08048421      894de4         mov dword [var_1ch], ecx    ; arg1
|           0x08048424      8955e0         mov dword [var_20h], edx    ; arg2
|           0x08048427      8b55e4         mov edx, dword [var_1ch]
|           0x0804842a      8b45e0         mov eax, dword [var_20h]
|           0x0804842d      01d0           add eax, edx
|           0x0804842f      8945f4         mov dword [var_ch], eax
|           0x08048432      8b45e0         mov eax, dword [var_20h]
|           0x08048435      2b450c         sub eax, dword [arg_ch]
|           0x08048438      8945f0         mov dword [var_10h], eax
|           0x0804843b      ff7508         push dword [arg_8h]
|           0x0804843e      ff75f0         push dword [var_10h]
|           0x08048441      ff75f4         push dword [var_ch]
|           0x08048444      6874850408     push str.i__i__i            ; 0x8048574 ; "%i %i %i\n"
|           0x08048449      e8a2feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804844e      83c410         add esp, 0x10
|           0x08048451      90             nop
|           0x08048452      c9             leave
\           0x08048453      c20800         ret 8
EOF
CMDS=<<EOF
aa
s sym.fastcaslled
afc fastcall
afc
afva
pdf
EOF
RUN

NAME=afva for cdecl/stdcall with no esp vars
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
cdecl
/ (fcn) sym.nonfastcaslled 51
|           ; var int32_t var_10h @ ebp-0x10
|           ; var int32_t var_ch @ ebp-0xc
|           ; arg int32_t arg_8h @ ebp+0x8
|           ; arg int32_t arg_ch @ ebp+0xc
|           ; arg int32_t arg_10h @ ebp+0x10
|           ; arg int32_t arg_14h @ ebp+0x14
|           ; CALL XREF from main (0x80484db)
|           0x08048456      55             push ebp
|           0x08048457      89e5           mov ebp, esp
|           0x08048459      83ec18         sub esp, 0x18
|           0x0804845c      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
|           0x0804845f      8b450c         mov eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|           0x08048462      01d0           add eax, edx
|           0x08048464      8945f4         mov dword [var_ch], eax
|           0x08048467      8b450c         mov eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|           0x0804846a      2b4514         sub eax, dword [arg_14h]
|           0x0804846d      8945f0         mov dword [var_10h], eax
|           0x08048470      ff7510         push dword [arg_10h]
|           0x08048473      ff75f0         push dword [var_10h]
|           0x08048476      ff75f4         push dword [var_ch]
|           0x08048479      6874850408     push str.i__i__i            ; 0x8048574 ; "%i %i %i\n"
|           0x0804847e      e86dfeffff     call sym.imp.printf
|           0x08048483      83c410         add esp, 0x10
|           0x08048486      90             nop
|           0x08048487      c9             leave
\           0x08048488      c3             ret
EOF
CMDS=<<EOF
e asm.calls=false
aa
s sym.nonfastcaslled
afc
afva
pdf
EOF
RUN

NAME=anal vars crash
FILE=-
EXPECT=<<EOF
EOF
CMDS=<<EOF
af
afvr-*
afvr-*
EOF
RUN

NAME=anal vars crash 2
FILE=-
EXPECT=<<EOF
/ (fcn) fcn.00000000 62
|           ; var int32_t my_local @ rbp-0x18
|           ; arg int32_t arg1 @ rdi
|           0x00000000      0000           add byte [rax], al
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch = x86
e anal.arch = x86
e asm.calls=false
wx 554889e5534881ec3810000048830c24004881c42010000064488b042528000000488945e831c04885ff4889fb909090909090c3 @ 10
aa
afvn new_1 old_1
afvn my_local var_18h
pd 1
EOF
RUN

NAME=afvb & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvn ImageHandle arg_8h
afvn SystemTable arg_ch
afvb~?ImageHandle
afvb~?SystemTable
EOF
RUN

NAME=afvb* & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvn ImageHandle arg_8h
afvn SystemTable arg_ch
afvb*~?ImageHandle
afvb*~?SystemTable
EOF
RUN

NAME=afvb idx... & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
afvb 8 ImageHandle blah @ 0x10002d8d
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvb*~ImageHandle
EOF
RUN

NAME=afvbj
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvbj~?ImageHandle
EOF
RUN

NAME=afvb-ArgName
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvb-ImageHandle
afvb~?ImageHandle
EOF
RUN

NAME=afvr & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr~?myreg
afvn blah myreg
afvr~?blah
EOF
RUN

NAME=afvr idx & afvr*
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr*~?myreg
afvr*~?int
EOF
RUN

NAME=afvr-name
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr-myreg
afvr~?myreg
EOF
RUN

NAME=afvb-* afvr-*
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
0
EOF
CMDS=<<EOF
af
afvb-*
afvr-*
afvb~?
afvr~?
EOF
RUN

NAME=anal vars count
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
13
EOF
CMDS=<<EOF
af
afvb~?
EOF
RUN

NAME=anal vars retype
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
var char var_30h @ rbp-0x30
EOF
CMDS=<<EOF
af
afvt var_30h char
afvb~_30h
EOF
RUN

NAME=anal vars rename
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
var int32_t newname @ rbp-0x30
EOF
CMDS=<<EOF
af
afvn newname var_30h
afvb~newname
EOF
RUN

NAME=vars commenting
FILE=malloc://1024
EXPECT=<<EOF
|           ; arg int var_8h @ rbp+0x8    ; comment
EOF
CMDS=<<EOF
af
afvb 8 var_8h int
Cvb 0x8 comment
pd1~comment
EOF
RUN

NAME=vars display in debugger
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
pf d @ebp+0xc
pf d @ebp-0x10
EOF
CMDS=<<EOF
aa
s 0x0804843b
afvd arg_ch
afvd var_10h
EOF
RUN

NAME=afvR and afvW test
FILE=../bins/elf/crackme0x05
EXPECT=<<EOF

   var_78h  0x8048577,0x804858a
    var_4h  
   var_78h  
    var_4h  0x804857a
EOF
CMDS=<<EOF
aa
s main
?e
afvR
afvW
EOF
RUN

NAME=axt avr
FILE=../bins/firmware/main.avr
EXPECT=<<EOF
            ; DATA XREF from str.hello ()
            0x00000260      80e0           ldi r24, 0x00
EOF
CMDS=<<EOF
f str.hello 12 @ 0x276
Csa 12 @ str.hello
axd 0x260 @ str.hello
pd 1 @ 0x260
EOF
RUN

NAME=axt capstone x86
FILE=../bins/elf/analysis/main
EXPECT=<<EOF
main 0x40050a [DATA] mov edi, str.Hello_World
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color=false
e scr.wheel = false
aa
axt @ str.Hello_World
EOF
RUN

NAME=axt capstone x86: IOLI0
FILE=../bins/elf/ioli/crackme0x00
EXPECT=<<EOF
main 0x804843c [DATA] mov dword [esp], str.Password:
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color=false
e scr.wheel = false
aa
axt @ str.Password:
EOF
RUN

NAME=axt capstone x86: IOLI7 aa
FILE=../bins/elf/ioli/crackme0x07
EXPECT=<<EOF
fcn.08048524 0x804853d [CALL] call sym.imp.exit
fcn.08048542 0x80485ab [CALL] call sym.imp.exit
fcn.080485b9 0x804866f [CALL] call sym.imp.exit
EOF
CMDS=<<EOF
aaa
axt @ sym.imp.exit
EOF
RUN

NAME=axt capstone x86: IOLI7 aa 2
FILE=../bins/elf/ioli/crackme0x07
EXPECT=<<EOF
fcn.08048524 0x804853d [CALL] call sym.imp.exit
fcn.08048542 0x80485ab [CALL] call sym.imp.exit
fcn.080485b9 0x804866f [CALL] call sym.imp.exit
EOF
CMDS=<<EOF
aaaa
axt @ sym.imp.exit
EOF
RUN

NAME=axt respect relsub
FILE=../bins/pe/ibknoreloc64.exe
EXPECT=<<EOF
entry0 0xffffffffffff100a [CALL] call qword [rip + 0xd8]
entry0 0xffffffffffff100a [CALL] call qword sym.imp.msvcrt.dll_printf
EOF
CMDS=<<EOF
aaa
e asm.relsub=false
axt @ sym.imp.msvcrt.dll_printf
e asm.relsub=true
axt @ sym.imp.msvcrt.dll_printf
EOF
RUN

NAME=ax-
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
EOF
CMDS=<<EOF
ax 10 20
axq
ax-10 20
axq
EOF
RUN

NAME=ax-@
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
EOF
CMDS=<<EOF
s 20
ax 10
axq
ax-10
axq
EOF
RUN

NAME=ax-*
FILE=-
EXPECT=<<EOF
                                       ? 0x0 ->   UNKNOWN -> 0xa
EOF
CMDS=<<EOF
ax 10
ax
ax-*
ax
EOF
RUN

NAME=axt unknown function
FILE=../bins/pe/lab11.malware
EXPECT=<<EOF
(nofunc) 0x401a1d [CALL] call fcn.00401270
EOF
CMDS=<<EOF
aaa
axt fcn.00401270
EOF
RUN

NAME=axf string ref capstone x86
FILE=../bins/elf/ioli/crackme0x03
EXPECT=<<EOF
sym.test 0x804848a [DATA] mov dword [esp], str.Sdvvzrug_RN
sym.test 0x804848a [DATA] mov dword [esp], str.Sdvvzrug_RN
d 0x80485fe str.Sdvvzrug_RN
d 0x80485fe str.Sdvvzrug_RN
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color = false
e scr.wheel = false
aa
axt str.Sdvvzrug_RN
s str.Sdvvzrug_RN
axt
axf 0x804848a
s 0x804848a
axf
EOF
RUN

NAME=x86 ref issue
FILE=-
EXPECT=<<EOF
0x00004434
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch=x86
wx c7052a44000050000000
ao~^ptr[1]
EOF
RUN

NAME=strings xref issue
FILE=../bins/elf/redpill
EXPECT=<<EOF
main 0x1457 [STRING] lea eax, str.Take_the_Red_Pill
main 0x148e [STRING] lea eax, str.use:_._exploit1_PILL
main 0x14eb [STRING] lea eax, str.Red_Pill__0x50444552
main 0x1502 [STRING] lea eax, str.Your_Pill_0x_08x
main 0x1523 [STRING] lea eax, str.Red_Pill
main 0x1557 [STRING] lea eax, str.fwhibbit
main 0x161d [STRING] lea eax, str.Blue_Pill
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
axt 0x00001d89
axt 0x00001da0
axt 0x00001db7
axt 0x00001dd1
axt 0x00001de8
axt 0x00001df4
axt 0x00001e09
EOF
RUN

NAME=reference to like mov [0x400000], 0x1234
FILE=../bins/elf/analysis/reference.out
EXPECT=<<EOF
main 0x80483ee [DATA] mov dword obj.a, 0x1337
EOF
CMDS=<<EOF
aaa
axt@0x0804a01c
EOF
RUN

NAME=delete references with ax-
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
0x00000014 -> 0x0000000a  UNKNOWN
0x00000028 -> 0x0000001e  UNKNOWN
EOF
CMDS=<<EOF
ax 10 20
axq
ax- 10
axq
ax 10 20
ax 30 40
axq
ax-*
axq
EOF
RUN

NAME=reference PIC binary
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
main 0x8048432 [STRING] lea eax, str.Hello_PIC
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
axt@0x80484e0
EOF
RUN

NAME=strings xref issue without relsub
FILE=../bins/elf/redpill
EXPECT=<<EOF
main 0x1457 [STRING] lea eax, [esi - 0x2277]
main 0x148e [STRING] lea eax, [esi - 0x2260]
main 0x14eb [STRING] lea eax, [esi - 0x2249]
main 0x1502 [STRING] lea eax, [esi - 0x222f]
main 0x1523 [STRING] lea eax, [esi - 0x2218]
main 0x1557 [STRING] lea eax, [esi - 0x220c]
main 0x161d [STRING] lea eax, [esi - 0x21f7]
EOF
CMDS=<<EOF
e anal.strings=true
e asm.relsub=false
aa
aae
axt 0x00001d89
axt 0x00001da0
axt 0x00001db7
axt 0x00001dd1
axt 0x00001de8
axt 0x00001df4
axt 0x00001e09
EOF
RUN

NAME=reference PIC binary without relsub
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
main 0x8048432 [STRING] lea eax, [ebx - 0x1b20]
EOF
CMDS=<<EOF
e anal.strings=true
e asm.relsub=false
aa
aae
axt@0x80484e0
EOF
RUN

NAME=refs on PIC binary disassembly
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
|           0x08048432      8d83e0e4ffff   lea eax, str.Hello_PIC      ; 0x80484e0 ; "Hello PIC!"
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
pd 1 @ 0x08048432
EOF
RUN

NAME=refs on PIC binary disassembly (color)
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
[36m|[0m [36m          [0m[32m0x08048432[0m      [37mlea[36m eax[0m,[36m [0m[33mstr.Hello_PIC[0m[36m[0m[0m
EOF
CMDS=<<EOF
e asm.bytes=false
e asm.comments=false
e scr.color=1
e anal.strings=true
aa
aae
pd 1 @ 0x08048432
EOF
RUN

NAME=axs
FILE=-
EXPECT=<<EOF
0x00000000 -> 0x00000010  STRING
EOF
CMDS=<<EOF
axs 0x10
axq
EOF
RUN

NAME=refs with aar
FILE=../bins/elf/crackme
EXPECT=<<EOF
;-- __libc_csu_fini:
; DATA XREF from entry0 (+0xf)
0x00400730      f3c3           ret
; CODE XREF from sym.__do_global_ctors_aux (+0x2d)
0x004007f0      4883eb08       sub rbx, 8
;-- __do_global_dtors_aux:
; CALL XREF from section..fini (+0x4)
0x00400610      55             push rbp
EOF
CMDS=<<EOF
e asm.lines.bb=false
e asm.lines.fcn=false
aar
pd 1 @0x400730
pd 1 @0x4007f0
pd 1 @0x400610
EOF
RUN

NAME=refs with afr
FILE=../bins/elf/crackme
EXPECT=<<EOF
(fcn) sym.__libc_csu_fini 2
  sym.__libc_csu_fini ();
; DATA XREF from entry0 (0x4005cf)
0x00400730      f3c3           ret
; CODE XREF from sym.__do_global_ctors_aux (0x4007fd)
0x004007f0      4883eb08       sub rbx, 8
(fcn) sym.__do_global_dtors_aux 100
  sym.__do_global_dtors_aux ();
; CALL XREF from sym._fini (0x40080c)
0x00400610      55             push rbp
EOF
CMDS=<<EOF
e asm.lines.bb=false
e asm.lines.fcn=false
e anal.jmp.cref=true
aa
afr
pd 1 @0x400730
pd 1 @0x4007f0
pd 1 @0x400610
EOF
RUN

NAME=cjmp data refs with aar
FILE=malloc://10000
EXPECT=<<EOF
; DATA XREF from unk ()
0x1000002e      00             nop
EOF
CMDS=<<EOF
e asm.arch=8051
e asm.lines.bb=false
e asm.lines.fcn=false
wx 307401000022
aar
pd 1 @_idata+0x2e
EOF
RUN

NAME=cjmp data refs with afr
FILE=malloc://10000
EXPECT=<<EOF
; DATA XREF from fcn.00000000 ()
0x1000002e      00             nop
EOF
CMDS=<<EOF
e asm.arch=8051
e asm.lines.bb=false
e asm.lines.fcn=false
wx 307401000022
aa
afr
pd 1 @_idata+0x2e
EOF
RUN

NAME=xrefs and overlapping basic blocks
FILE=../bins/elf/analysis/ls-linux-x86_64-zlul
CMDS=<<EXPECT
aaa
axt main
EXPECT=<<RUN
entry0 0x40488d [DATA] mov rdi, main
RUN

NAME=unique function names
FILE=../bins/elf/bash
CMDS=<<EXPECT
aaa
f~strlen~390
EXPECT=''
RUN

NAME=no function split without overlapping blocks
FILE=../bins/elf/libc.so.6
CMDS=<<EXPECT
aac
s 0x2254d
agf~invalid
echo end
EXPECT=end
RUN

NAME=noreturn of reloc-functions
FILE=../bins/elf/ls
CMDS=<<EXPECT
aaa
afbr 0x80b0
EXPECT=<<RUN
0x000081cb
0x00008237
RUN

NAME=r_anal_fcn_split_bb FITFCNSZ fix (#12008)
FILE=-
CMDS=<<EXPECT
e anal.jmp.mid=false
e io.cache=true
wx b8210000c1ebfdbb2c000000000
af
afi
?e
afb
?e
e asm.bb.middle=true
pdf
?e
e asm.bb.middle=false
pdf
EXPECT=<<RUN
#
offset: 0x00000000
name: fcn.00000000
size: 7
is-pure: true
realsz: 7
stackframe: 0
call-convention: amd64
cyclomatic-cost : 4
cyclomatic-complexity: 0
bits: 64
type: fcn [NEW]
num-bbs: 2
edges: 2
end-bbs: 0
call-refs:
data-refs:
code-xrefs:
in-degree: 0
out-degree: 0
data-xrefs:
locals: 0
args: 0
diff: type: new

0x00000000 0x00000004 00:0000 4 j 0x00000004
0x00000004 0x00000007 00:0000 3 j 0x00000004

/ (fcn) fcn.00000000 7
|   fcn.00000000 ();
|           0x00000000  ~   b8210000c1     mov eax, 0xc1000021         ; '!'
|           ; CODE XREF from fcn.00000000 (0x5)
\       .-> 0x00000004      c1ebfd         shr ebx, 0xfd

/ (fcn) fcn.00000000 7
|   fcn.00000000 ();
|           0x00000000      b8210000c1     mov eax, 0xc1000021         ; '!'
\       `=< 0x00000005      ebfd           jmp 4
RUN

NAME=overlapping basic blocks and anal.jmp.mid
FILE=-
CMDS=<<EXPECT
e asm.bb.middle=true
e anal.jmp.mid=true
e io.cache=true
"(show_fcn bin, wx $0, af-*, af, afi, ?e, afb, ?e, pdr, ?e, agf, ?e, e asm.bb.middle=true, pdf, ?e, e asm.bb.middle=false, pdf)"
.(show_fcn b8210000c1ebfdbb2c000000cc)
?e
.(show_fcn b8210000c1ebfdbb2c000000ebf6)
?e
.(show_fcn b8210000c1ebfdbb2c000000ebf7)
?e
# e anal.nopskip=false  # TODO: why not needed?
.(show_fcn 0f1f440000b8210000c1ebfdbb2c000000ebf0)
EXPECT=<<RUN
#
offset: 0x00000000
name: fcn.00000000
size: 13
is-pure: false
realsz: 16
stackframe: 0
call-convention: amd64
cyclomatic-cost : 6
cyclomatic-complexity: 1
bits: 64
type: fcn [NEW]
num-bbs: 2
edges: 1
end-bbs: 1
call-refs: 0x00000004 J
data-refs: 0x0000002c
code-xrefs: 0x00000005 J
in-degree: 1
out-degree: 0
data-xrefs:
locals: 0
args: 0
diff: type: new

0x00000000 0x00000007 00:0000 7 j 0x00000004
0x00000004 0x0000000d 00:0000 9

/ (fcn) fcn.00000000 16
|   fcn.00000000 ();
| 0x00000000      b8210000c1     mov eax, 0xc1000021                   ; '!'
| 0x00000005      ebfd           jmp 4
| ----------- true: 0x00000004
| ; CODE XREF from fcn.00000000 (0x5)
| 0x00000004      c1ebfd         shr ebx, 0xfd
| 0x00000007      bb2c000000     mov ebx, 0x2c                         ; ','
\ 0x0000000c      cc             int3


[0x00000000]>  # fcn.00000000 ();
      .------------------------.
      |  0x0                   |
      | (fcn) fcn.00000000 16  |
      |   fcn.00000000 ();     |
      | ; '!'                  |
      | mov eax, 0xc1000021    |
      | jmp 4                  |
      `------------------------'
          v
          |
    .-----'
    |
.-------------------------------------.
|  0x4                                |
| ; CODE XREF from fcn.00000000 (0x5) |
| shr ebx, 0xfd                       |
| ; ','                               |
| mov ebx, 0x2c                       |
| int3                                |
`-------------------------------------'

/ (fcn) fcn.00000000 16
|   fcn.00000000 ();
|           0x00000000  ~   b8210000c1     mov eax, 0xc1000021         ; '!'
|           ; CODE XREF from fcn.00000000 (0x5)
|       .-> 0x00000004      c1ebfd         shr ebx, 0xfd
|           0x00000007      bb2c000000     mov ebx, 0x2c               ; ','
\           0x0000000c      cc             int3
..

/ (fcn) fcn.00000000 16
|   fcn.00000000 ();
|           0x00000000      b8210000c1     mov eax, 0xc1000021         ; '!'
|       `=< 0x00000005      ebfd           jmp 4
|           0x00000007      bb2c000000     mov ebx, 0x2c               ; ','
\           0x0000000c      cc             int3
..

#
offset: 0x00000000
name: fcn.00000000
size: 14
is-pure: false
realsz: 17
stackframe: 0
call-convention: amd64
cyclomatic-cost : 7
cyclomatic-complexity: 0
bits: 64
type: fcn [NEW]
num-bbs: 2
edges: 2
end-bbs: 0
call-refs: 0x00000004 J 0x00000004 J
data-refs: 0x0000002c
code-xrefs: 0x00000005 J 0x0000000c J
in-degree: 2
out-degree: 0
data-xrefs:
locals: 0
args: 0
diff: type: new

0x00000000 0x00000007 00:0000 7 j 0x00000004
0x00000004 0x0000000e 00:0000 10 j 0x00000004

/ (fcn) fcn.00000000 17
|   fcn.00000000 ();
| 0x00000000      b8210000c1     mov eax, 0xc1000021                   ; '!'
| 0x00000005      ebfd           jmp 4
| ----------- true: 0x00000004
| ; CODE XREFS from fcn.00000000 (0x5, 0xc)
| 0x00000004      c1ebfd         shr ebx, 0xfd
| 0x00000007      bb2c000000     mov ebx, 0x2c                         ; ','
\ 0x0000000c      ebf6           jmp 4
| ----------- true: 0x00000004

[0x00000000]>  # fcn.00000000 ();
          .------------------------.
          |  0x0                   |
          | (fcn) fcn.00000000 17  |
          |   fcn.00000000 ();     |
          | ; '!'                  |
          | mov eax, 0xc1000021    |
          | jmp 4                  |
          `------------------------'
              v
              |
              '--------.
                       |
                       |
                       |
       .---------------'
.--------.
|      | |
|.-------------------------------------------.
||  0x4                                      |
|| ; CODE XREFS from fcn.00000000 (0x5, 0xc) |
|| shr ebx, 0xfd                             |
|| ; ','                                     |
|| mov ebx, 0x2c                             |
|| jmp 4                                     |
|`-------------------------------------------'
|    v
|    |
`----'

/ (fcn) fcn.00000000 17
|   fcn.00000000 ();
|           0x00000000  ~   b8210000c1     mov eax, 0xc1000021         ; '!'
|           ; CODE XREFS from fcn.00000000 (0x5, 0xc)
|      ..-> 0x00000004      c1ebfd         shr ebx, 0xfd
|       :   0x00000007      bb2c000000     mov ebx, 0x2c               ; ','
\       `=< 0x0000000c      ebf6           jmp 4
..

/ (fcn) fcn.00000000 17
|   fcn.00000000 ();
|           0x00000000      b8210000c1     mov eax, 0xc1000021         ; '!'
|      `==< 0x00000005      ebfd           jmp 4
|       :   0x00000007      bb2c000000     mov ebx, 0x2c               ; ','
\       `=< 0x0000000c      ebf6           jmp 4
..

#
offset: 0x00000000
name: fcn.00000000
size: 14
is-pure: false
realsz: 17
stackframe: 0
call-convention: amd64
cyclomatic-cost : 7
cyclomatic-complexity: 0
bits: 64
type: fcn [NEW]
num-bbs: 3
edges: 3
end-bbs: 0
call-refs: 0x00000004 J 0x00000005 J
data-refs: 0x0000002c
code-xrefs: 0x00000005 J 0x0000000c J
in-degree: 2
out-degree: 0
data-xrefs:
locals: 0
args: 0
diff: type: new

0x00000000 0x00000005 00:0000 5 j 0x00000005
0x00000004 0x0000000e 00:0000 10 j 0x00000005
0x00000005 0x00000007 00:0000 2 j 0x00000004

/ (fcn) fcn.00000000 17
|   fcn.00000000 ();
| 0x00000000      b8210000c1     mov eax, 0xc1000021                   ; '!'
| ----------- true: 0x00000005
| ; CODE XREF from fcn.00000000 (0x5)
| 0x00000004      c1ebfd         shr ebx, 0xfd
| 0x00000007      bb2c000000     mov ebx, 0x2c                         ; ','
  0x0000000c      ebf7           jmp 5                                 ; fcn.00000000+0x5
| ----------- true: 0x00000005
| ; CODE XREF from fcn.00000000 (+0xc)
| 0x00000005      ebfd           jmp 4
| ----------- true: 0x00000004

[0x00000000]>  # fcn.00000000 ();
        .------------------------.
        |  0x0                   |
        | (fcn) fcn.00000000 17  |
        |   fcn.00000000 ();     |
        | ; '!'                  |
        | mov eax, 0xc1000021    |
        `------------------------'
            v
            |
       .----'
.--------.
|      | |
|.--------------------------------------.
||  0x5                                 |
|| ; CODE XREF from fcn.00000000 (+0xc) |
|| jmp 4                                |
|`--------------------------------------'
|    v
|    |
|    '.
|     |
| .-------------------------------------.
| |  0x4                                |
| | ; CODE XREF from fcn.00000000 (0x5) |
| | shr ebx, 0xfd                       |
| | ; ','                               |
| | mov ebx, 0x2c                       |
| | jmp 5                               |
| `-------------------------------------'
|     v
|     |
`-----'

/ (fcn) fcn.00000000 17
|   fcn.00000000 ();
|           0x00000000  ~   b8210000c1     mov eax, 0xc1000021         ; '!'
|           ; CODE XREF from fcn.00000000 (0x5)
|       .-> 0x00000004  ~   c1ebfd         shr ebx, 0xfd
|       |   ; CODE XREF from fcn.00000000 (+0xc)
|      .`=< 0x00000005      ebfd           jmp 4
|      :    0x00000007      bb2c000000     mov ebx, 0x2c               ; ','
       `==< 0x0000000c      ebf7           jmp 5                       ; fcn.00000000+0x5
..

/ (fcn) fcn.00000000 17
|   fcn.00000000 ();
|           0x00000000      b8210000c1     mov eax, 0xc1000021         ; '!'
|       |   ; CODE XREF from fcn.00000000 (+0xc)
|      .`=< 0x00000005      ebfd           jmp 4
|      :    0x00000007      bb2c000000     mov ebx, 0x2c               ; ','
       `==< 0x0000000c      ebf7           jmp 5                       ; fcn.00000000+0x5
..

#
offset: 0x00000000
name: fcn.00000000
size: 19
is-pure: false
realsz: 24
stackframe: 0
call-convention: amd64
cyclomatic-cost : 9
cyclomatic-complexity: 0
bits: 64
type: fcn [NEW]
num-bbs: 4
edges: 4
end-bbs: 0
call-refs: 0x00000009 J 0x00000003 J
data-refs: 0x0000002c
code-xrefs: 0x00000011 J 0x0000000a J
in-degree: 2
out-degree: 0
data-xrefs:
locals: 0
args: 0
diff: type: new

0x00000000 0x00000005 00:0000 5 j 0x00000005
0x00000003 0x00000005 00:0000 2 j 0x00000005
0x00000005 0x0000000c 00:0000 7 j 0x00000009
0x00000009 0x00000013 00:0000 10 j 0x00000003

/ (fcn) fcn.00000000 24
|   fcn.00000000 ();
| 0x00000000      0f1f440000     nop dword [rax + rax]
| ----------- true: 0x00000005
| ; CODE XREF from fcn.00000000 (0x11)
| 0x00000003      0000           add byte [rax], al
| ----------- true: 0x00000005
| 0x00000005      b8210000c1     mov eax, 0xc1000021                   ; '!'
| 0x0000000a      ebfd           jmp 9
| ----------- true: 0x00000009
| ; CODE XREF from fcn.00000000 (0xa)
| 0x00000009      c1ebfd         shr ebx, 0xfd
| 0x0000000c      bb2c000000     mov ebx, 0x2c                         ; ','
\ 0x00000011      ebf0           jmp 3
| ----------- true: 0x00000003

[0x00000000]>  # fcn.00000000 ();
       .--------------------------.
       |  0x0                     |
       | (fcn) fcn.00000000 24    |
       |   fcn.00000000 ();       |
       | nop dword [rax + rax]    |
       `--------------------------'
           v
           |
           '--.
.---------------.
|             | |
|       .------------------------.
|       |  0x5                   |
|       | ; '!'                  |
|       | mov eax, 0xc1000021    |
|       | jmp 9                  |
|       `------------------------'
|           v
|           |
|     .-----'
|     |
| .-------------------------------------.
| |  0x9                                |
| | ; CODE XREF from fcn.00000000 (0xa) |
| | shr ebx, 0xfd                       |
| | ; ','                               |
| | mov ebx, 0x2c                       |
| | jmp 3                               |
| `-------------------------------------'
|     v
|     |
|    .'
|    |
|.--------------------------------------.
||  0x3                                 |
|| ; CODE XREF from fcn.00000000 (0x11) |
|| add byte [rax], al                   |
|`--------------------------------------'
|    v
|    |
`----'

/ (fcn) fcn.00000000 24
|   fcn.00000000 ();
|           0x00000000  ~   0f1f440000     nop dword [rax + rax]
|           ; CODE XREF from fcn.00000000 (0x11)
|       .-> 0x00000003      0000           add byte [rax], al
|       :   0x00000005  ~   b8210000c1     mov eax, 0xc1000021         ; '!'
|       :   ; CODE XREF from fcn.00000000 (0xa)
|      .--> 0x00000009      c1ebfd         shr ebx, 0xfd
|       :   0x0000000c      bb2c000000     mov ebx, 0x2c               ; ','
\       `=< 0x00000011      ebf0           jmp 3
..

/ (fcn) fcn.00000000 24
|   fcn.00000000 ();
|           0x00000000      0f1f440000     nop dword [rax + rax]
|       :   0x00000005      b8210000c1     mov eax, 0xc1000021         ; '!'
|      `==< 0x0000000a      ebfd           jmp 9
|       :   0x0000000c      bb2c000000     mov ebx, 0x2c               ; ','
\       `=< 0x00000011      ebf0           jmp 3
..
RUN

NAME=so -N and overlapping basic blocks
FILE=-
CMDS=<<EXPECT
e anal.jmp.mid=true
e io.cache=true
e anal.nopskip=false
wx 0f1f440000b8210000c1ebfdbb2c000000ebf0
af
s 0x4
so -1
s
s 0x4
so -2
s
EXPECT=<<RUN
0x3
0x0
RUN

NAME=a8 analyze bytes
FILE=-
EXPECT=<<EOF
address: 0x0
opcode: push rbp
mnemonic: push
prefix: 0
id: 588
bytes: 55
refptr: 0
size: 1
sign: false
type: upush
cycles: 2
esil: rbp,8,rsp,-,=[8],8,rsp,-=
stack: inc
family: cpu
stackop: inc
stackptr: 8
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
e asm.os=linux
a8 55|
EOF
RUN

NAME=af jmp after ret
FILE=malloc://512
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
af
afl~?
EOF
RUN

NAME=af jmp after ret
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
af
afl~?
afl~[2]
EOF
RUN

NAME=Windows Function EMU LoadStringA
FILE=../bins/pe/standard.exe
EXPECT=<<EOF
  0x00402b00      call dword [sym.imp.user32.dll_LoadStringA] ; 0x402d40 ; esp=0x177ff0 ; eip=0x2cfa reloc.user32.dll_LoadStringA
                    ; int LoadStringA(NULL, -1, NULL, -1)
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
e asm.os=windows
e asm.emu=true
e emu.write=true
e asm.bytes=0
e asm.cmt.col=20
e asm.lines.bb=false
e io.cache=true
aeim
s 0x00402aee
pd 10~LoadString
EOF
RUN

NAME=Linux fcnsign test
FILE=../bins/elf/analysis/ls-linux64
EXPECT=<<EOF
0x00003cb8      call sym.imp.getenv ; rsp=0x177fe8 -> 0x464c457f ; rip=0x3430 -> 0x97fa25ff
                    ; char *getenv("COLUMNS")
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
e asm.os=linux
e asm.emu=true
e emu.write=true
e asm.bytes=0
e asm.cmt.col=20
e asm.lines.bb=false
e asm.lines.fcn=false
aa
aeim
s 0x00003cb8-0x30
pd 20~env
EOF
RUN

NAME=sar on x86-64
FILE=-
EXPECT=<<EOF
0xfffffffffffffffc
0xfffffffffffffffe
0xffffffffffffffff
0xffffffffffffffff
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
e anal.hasnext=0
# testing mov eax, -4 sar
wx 48c7c0fcffffff 48d1f8 48d1f8 48d1f8 48d1f8 48d1f8 48d1f8
aes
dr?rax
aes
dr?rax
aes
dr?rax
aes
dr?rax
EOF
RUN

NAME=aes
FILE=-
EXPECT=<<EOF
0xfffffffffffffffc
0xfffffffffffffffe
0xffffffffffffffff
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
e anal.hasnext=0
wx 48c7c0fcffffff 48d1f8 48d1f8 48d1f8
aes
dr?rax
aes
dr?rax
aes
dr?rax
EOF
RUN

NAME=x86-64 after unknown jmp
FILE=../bins/elf/analysis/ls-linux64
EXPECT=<<EOF
lea rdi, [rip + 0x217631]
lea rax, [rip + 0x217631]
push rbp
sub rax, rdi
mov rbp, rsp
cmp rax, 0xe
jbe 0x5c80
mov rax, qword [rip + 0x217316]
test rax, rax
je 0x5c80
pop rbp
jmp rax
nop word [rax + rax]
pop rbp
ret
EOF
CMDS=<<EOF
s 0x5c50
af
pif
EOF
RUN

NAME=t.anal/x86/aap
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
push rbp
mov rbp, rsp
EOF
ARGS=
CMDS=<<EOF
f-sym.func.*
aap
pi 2 @ fcn.1000010f8
EOF
RUN

NAME=mac-ls switch count
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
0x100001527 1 switch.0x100001527
EOF
CMDS=<<EOF
e anal.jmp.tbl=true
af
f~switch
EOF
RUN

NAME=gcc_5.5.0_64 switch/case flags
FILE=../bins/jmptbl/test_gcc_5.5.0_64.out
EXPECT=<<EOF
0x0000059d 1 switch.0x0000059d
0x0000059f 1 case.0x59d.13
0x000005b2 1 case.0x59d.1
0x000005c0 1 case.0x59d.2
0x000005c0 1 case.0x59d.3
0x000005c0 1 case.0x59d.4
0x000005ce 1 case.0x59d.5
0x000005dc 1 case.0x59d.6
0x000005ea 1 case.0x59d.7
0x000005f8 1 case.0x59d.9
0x00000606 1 case.0x59d.11
0x00000614 1 case.0x59d.12
0x00000622 1 case.0x59d.0
0x00000622 1 case.0x59d.8
0x00000622 1 case.0x59d.10
0x00000622 1 case.default.0x622
EOF
CMDS=<<EOF
aaa
f~switch
f~case.
EOF
RUN

NAME=gcc_7.2.0_64 switch/case flags
FILE=../bins/jmptbl/test_gcc_7.2.0_64.out
EXPECT=<<EOF
0x0000054d 1 switch.0x0000054d
0x0000054f 1 case.0x54d.13
0x00000562 1 case.0x54d.1
0x00000570 1 case.0x54d.2
0x00000570 1 case.0x54d.3
0x00000570 1 case.0x54d.4
0x0000057e 1 case.0x54d.5
0x0000058c 1 case.0x54d.6
0x0000059a 1 case.0x54d.7
0x000005a8 1 case.0x54d.9
0x000005b6 1 case.0x54d.11
0x000005c4 1 case.0x54d.12
0x000005d2 1 case.0x54d.0
0x000005d2 1 case.0x54d.8
0x000005d2 1 case.0x54d.10
0x000005d2 1 case.default.0x5d2
EOF
CMDS=<<EOF
aaa
f~switch
f~case.
EOF
RUN

NAME=clang_3.8_64 switch/case flags
FILE=../bins/jmptbl/test_clang_3.8_64.out
EXPECT=<<EOF
0x004004d8 1 switch.0x004004d8
0x004004df 1 case.0x4004d8.1
0x004004df 1 case.0x4004d8.2
0x004004df 1 case.0x4004d8.3
0x004004e6 1 case.0x4004d8.0
0x004004ed 1 case.0x4004d8.4
0x004004f4 1 case.0x4004d8.5
0x004004fb 1 case.0x4004d8.6
0x00400502 1 case.0x4004d8.7
0x00400502 1 case.0x4004d8.9
0x00400502 1 case.default.0x400502
0x00400509 1 case.0x4004d8.8
0x00400510 1 case.0x4004d8.10
0x00400517 1 case.0x4004d8.11
0x0040051e 1 case.0x4004d8.12
EOF
CMDS=<<EOF
aaa
f~switch
f~case.
EOF
RUN

NAME=clang_5.0_64 switch/case flags
FILE=../bins/jmptbl/test_clang_5.0_64.out
EXPECT=<<EOF
0x004004c8 1 switch.0x004004c8
0x004004cf 1 case.0x4004c8.1
0x004004cf 1 case.0x4004c8.2
0x004004cf 1 case.0x4004c8.3
0x004004d6 1 case.0x4004c8.0
0x004004dd 1 case.0x4004c8.4
0x004004e4 1 case.0x4004c8.5
0x004004eb 1 case.0x4004c8.6
0x004004f2 1 case.0x4004c8.7
0x004004f2 1 case.0x4004c8.9
0x004004f2 1 case.default.0x4004f2
0x004004f9 1 case.0x4004c8.8
0x00400500 1 case.0x4004c8.10
0x00400507 1 case.0x4004c8.11
0x0040050e 1 case.0x4004c8.12
EOF
CMDS=<<EOF
aaa
f~switch
f~case.
EOF
RUN

NAME=msvc_1700_64 switch/case flags
FILE=../bins/jmptbl/test_msvc_1700_64.exe
EXPECT=<<EOF
0x140001023 1 switch.0x140001023
0x140004b01 1 switch.0x140004b01
0x140001025 1 case.0x140001023.0
0x140001038 1 case.0x140001023.1
0x140001038 1 case.0x140001023.2
0x140001038 1 case.0x140001023.3
0x14000104b 1 case.0x140001023.4
0x14000105e 1 case.0x140001023.5
0x140001071 1 case.0x140001023.6
0x140001084 1 case.0x140001023.8
0x140001097 1 case.0x140001023.10
0x1400010aa 1 case.0x140001023.11
0x1400010bd 1 case.0x140001023.12
0x1400010d0 1 case.0x140001023.7
0x1400010d0 1 case.0x140001023.9
0x1400010d0 1 case.default.0x1400010d0
0x140004a40 1 case.default.0x140004a40
0x140004b47 1 case.0x140004b01.0
0x140004b4b 1 case.0x140004b01.1
0x140004b56 1 case.0x140004b01.2
0x140004b62 1 case.0x140004b01.3
0x140004b77 1 case.0x140004b01.4
0x140004b80 1 case.0x140004b01.5
0x140004b92 1 case.0x140004b01.6
0x140004ba5 1 case.0x140004b01.7
0x140004bc1 1 case.0x140004b01.8
0x140004bcb 1 case.0x140004b01.9
0x140004bde 1 case.0x140004b01.10
0x140004bf2 1 case.0x140004b01.11
0x140004c0f 1 case.0x140004b01.12
0x140004c20 1 case.0x140004b01.13
0x140004c3a 1 case.0x140004b01.14
0x140004c55 1 case.0x140004b01.15
0x140004c79 1 case.0x140004b01.16
EOF
CMDS=<<EOF
aaa
f~switch
f~case.
EOF
RUN

NAME=msvc_1900_64 switch/case flags
FILE=../bins/jmptbl/test_msvc_1900_64.exe
EXPECT=<<EOF
0x140001023 1 switch.0x140001023
0x1400095b4 1 switch.0x1400095b4
0x14000c185 1 switch.0x14000c185
0x140001025 1 case.0x140001023.0
0x140001038 1 case.0x140001023.1
0x140001038 1 case.0x140001023.2
0x140001038 1 case.0x140001023.3
0x14000104b 1 case.0x140001023.4
0x14000105e 1 case.0x140001023.5
0x140001071 1 case.0x140001023.6
0x140001084 1 case.0x140001023.8
0x140001097 1 case.0x140001023.10
0x1400010aa 1 case.0x140001023.11
0x1400010bd 1 case.0x140001023.12
0x1400010d0 1 case.0x140001023.7
0x1400010d0 1 case.0x140001023.9
0x1400010d0 1 case.default.0x1400010d0
0x1400095b6 1 case.0x1400095b4.0
0x1400095bd 1 case.0x1400095b4.1
0x1400095c4 1 case.0x1400095b4.2
0x1400095cb 1 case.0x1400095b4.3
0x1400095d2 1 case.0x1400095b4.4
0x1400095d9 1 case.0x1400095b4.5
0x1400095e0 1 case.0x1400095b4.6
0x1400095e7 1 case.0x1400095b4.7
0x1400095ee 1 case.0x1400095b4.8
0x1400095f5 1 case.0x1400095b4.9
0x1400095fc 1 case.0x1400095b4.10
0x140009603 1 case.0x1400095b4.11
0x14000960a 1 case.0x1400095b4.12
0x140009611 1 case.0x1400095b4.13
0x140009618 1 case.0x1400095b4.14
0x14000961d 1 case.default.0x14000961d
0x14000c100 1 case.default.0x14000c100
0x14000c1d0 1 case.0x14000c185.0
0x14000c1d1 1 case.0x14000c185.2
0x14000c1d8 1 case.0x14000c185.8
0x14000c1df 1 case.0x14000c185.3
0x14000c1ef 1 case.0x14000c185.1
0x14000c1f5 1 case.0x14000c185.16
0x14000c200 1 case.0x14000c185.11
0x14000c21b 1 case.0x14000c185.4
0x14000c220 1 case.0x14000c185.5
0x14000c230 1 case.0x14000c185.6
0x14000c240 1 case.0x14000c185.7
0x14000c258 1 case.0x14000c185.13
0x14000c270 1 case.0x14000c185.9
0x14000c280 1 case.0x14000c185.10
0x14000c290 1 case.0x14000c185.12
0x14000c2a0 1 case.0x14000c185.14
0x14000c2c0 1 case.0x14000c185.15
EOF
CMDS=<<EOF
aaa
f~switch
f~case.
EOF
RUN

NAME=./noncode
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
e anal.noncode=false
afr
afl~?str.
EOF
RUN

NAME=./noncode
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
e anal.noncode=false
e anal.calls=true
af
afl~?str.
EOF
RUN
